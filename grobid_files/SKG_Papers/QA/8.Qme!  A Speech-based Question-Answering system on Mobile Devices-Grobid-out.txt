title
Qme! : A Speech-based Question-Answering system on Mobile Devices

abstract
Mobile devices are becoming the dominant mode of information access despite being cumbersome to input text using small keyboards and browsing web pages on small screens. We present Qme!, a speech-based question-answering system that allows for spoken queries and retrieves answers to the questions instead of web pages. We present bootstrap methods to distinguish dynamic questions from static questions and we show the benefits of tight coupling of speech recognition and retrieval components of the system.

Introduction Access to information has moved from desktop and laptop computers in office and home environments to be an any place, any time activity due to mobile devices. Although mobile devices have small keyboards that make typing text input cumbersome compared to conventional desktop and laptops, the ability to access unlimited amount of information, almost everywhere, through the Internet, using these devices have made them pervasive. Even so, information access using text input on mobile devices with small screens and soft/small keyboards is tedious and unnatural. In addition, by the mobile nature of these devices, users often like to use them in hands-busy environments, ruling out the possibility of typing text. We address this issue by allowing the user to query an information repository using speech. We expect that spoken language queries to be a more natural and less cumbersome way of information access using mobile devices. A second issue we address is related to directly and precisely answering the user's query beyond serving web pages. This is in contrast to the current approach where a user types in a query using keywords to a search engine, browses the returned results on the small screen to select a potentially relevant document, suitably magnifies the screen to view the document and searches for the answer to her question in the document. By providing a method for the user to pose her query in natural language and presenting the relevant answer(s) to her question, we expect the user's information need to be fulfilled in a shorter period of time. We present a speech-driven question answering system, Qme!, as a solution toward addressing these two issues. The system provides a natural input modality -spoken language input -for the users to pose their information need and presents a collection of answers that potentially address the information need directly. For a subclass of questions that we term static questions, the system retrieves the answers from an archive of human generated answers to questions. This ensures higher accuracy for the answers retrieved (if found in the archive) and also allows us to retrieve related questions on the user's topic of interest. For a second subclass of questions that we term dynamic questions, the system retrieves the answer from information databases accessible over the Internet using web forms. The layout of the paper is as follows. In Section 2, we review the related literature. In Section 3, we illustrate the system for speech-driven question answering. We present the retrieval methods we used to implement the system in Section 4. In Section 5, we discuss and evaluate our approach to tight coupling of speech recognition and search components. In Section 6, we present bootstrap techniques to distinguish dynamic questions from static questions, and evaluate the efficacy of these techniques on a test corpus. We conclude in Section 7. 

 Related Work Early question-answering (QA) systems, such as Baseball  (Green et al., 1961)  and Lunar  (Woods, 1973)  were carefully hand-crafted to answer questions in a limited domain, similar to the QA components of ELIZA  (Weizenbaum, 1966)  and SHRDLU  (Winograd, 1972) . However, there has been a resurgence of QA systems following the TREC conferences with an emphasis on answering factoid questions. This work on text-based questionanswering which is comprehensively summarized in  (Maybury, 2004) , range widely in terms of linguistic sophistication. At one end of the spectrum, There are linguistically motivated systems  (Katz, 1997; Waldinger et al., 2004 ) that analyze the user's question and attempt to synthesize a coherent answer by aggregating the relevant facts. At the other end of the spectrum, there are data intensive systems  (Dumais et al., 2002)  that attempt to use the redundancy of the web to arrive at an answer for factoid style questions. There are also variants of such QA techniques that involve an interaction and use context to resolve ambiguity  (Yang et al., 2006) . In contrast to these approaches, our method matches the user's query against the questions in a large corpus of question-answer pairs and retrieves the associated answer. In the information retrieval community, QA systems attempt to retrieve precise segments of a document instead of the entire document. In  (Tomuro and Lytinen, 2004) , the authors match the user's query against a frequently-asked-questions (FAQ) database and select the answer whose question matches most closely to the user's question. An extension of this idea is explored in  (Xue et al., 2008; Jeon et al., 2005) , where the authors match the user's query to a community collected QA archive such as  (Yahoo!, 2009; MSN-QnA, 2009) . Our approach is similar to both these lines of work in spirit, although the user's query for our system originates as a spoken query, in contrast to the text queries in previous work. We also address the issue of noisy speech recognition and assess the value of tight integration of speech recognition and search in terms of improving the overall performance of the system. A novelty in this paper is our method to address dynamic questions as a seamless extension to answering static questions. Also related is the literature on voice-search applications  (Microsoft, 2009; Google, 2009; Yellow-Pages, 2009; vlingo.com, 2009 ) that provide a spoken language interface to business directories and return phone numbers, addresses and web sites of businesses. User input is typically not a free flowing natural language query and is limited to expressions with a business name and a location. In our system, users can avail of the full range of natural language expressions to express their information need. And finally, our method of retrieving answers to dynamic questions has relevance to the database and meta search community. There is growing interest in this community to mine the "hidden" web -infor-mation repositories that are behind web forms -and provide a unified meta-interface to such information sources, for example, web sites related travel, or car dealerships. Dynamic questions can be seen as providing a natural language interface (NLI) to such web forms, similar to early work on NLI to databases  (Androutsopoulos, 1995) . 

 Speech-driven Question Retrieval System We describe the speech-driven query retrieval application in this section. The user of this application provides a spoken language query to a mobile device intending to find an answer to the question. Some example users' inputs are 1 what is the fastest animal in water, how do I fix a leaky dishwasher, why is the sky blue. The result of the speech recognizer is used to search a large corpus of question-answer pairs to retrieve the answers pertinent to the user's static questions. For the dynamic questions, the answers are retrieved by querying a web form from the appropriate web site (e.g www.fandango.com for movie information). The result from the speech recognizer can be a single-best string or a weighted word lattice.  2  The retrieved results are ranked using different metrics discussed in the next section. In Figure  2 , we illustrate the answers that Qme!returns for static and dynamic quesitons.   

 Methods of Retrieval We formulate the problem of answering static questions as follows. Given a question-answer archive QA = {(q 1 , a 1 ), (q 2 , a 2 ), . . . , (q N , a N )} of N question-answer pairs, and a user's question q u , the task is to retrieve a subset QA r = {(q r 1 , a r 1 ), (q r 2 , a r 2 ), . . . , (q r M , a r M )} M << N using a selection function Select and rank the members of QA r using a scoring function Score such that Score(q u , (q r i , a r i )) > Score(q u , (q r i+1 , a r i+1 )). Here, we assume Score(q u , (q r i , a r i )) = Score(q u , q r i ). The Select function is intended to select the matching questions that have high "semantic" similarity to the user's question. However, given there is no objective function that measures semantic similarity, we approximate it using different metrics discussed below. Ranking of the members of the retrieved set can be based on the scores computed during the selection step or can be independently computed based on other criteria such as popularity of the question, credibility of the source, temporal recency of the answer, geographical proximity to the answer origin. 

 Question Retrieval Metrics We retrieve QA pairs from the data repository based on the similarity of match between the user's query and each of the set of questions (d) in the repository. To measure the similarity, we have experimented with the following metrics. 

 TF-IDF metric: The user input query and the document (in our case, questions in the repository) are represented as bag-of-n-grams (aka terms). The term weights are computed using a combination of term frequency (tf ) and inverse document frequency (idf )  (Robertson, 2004) . If Q = q 1 , q 2 , . . . , q n is a user query, then the aggregated score for a document d using a unigram model of the query and the document is given as in Equation  1 . For a given query, the documents with the highest total term weight are presented as retrieved results. Terms can also be defined as n-gram sequences of a query and a document. In our experiments, we have used up to 4-grams as terms to retrieve and rank documents. Score(d) = w?Q tf w,d ? idf w (1) 2. String Comparison Metrics: Since the length of the user query and the query to be retrieved are similar in length, we use string comparison methods such as Levenshtein edit distance  (Levenshtein, 1966)  and n-gram overlap (BLEU-score)  (Papineni et al., 2002)  as similarity metrics. We compare the search effectiveness of these similarity metrics in Section 5.3. 

 Tightly coupling ASR and Search Most of the speech-driven search systems use the 1-best output from the ASR as the query for the search component. Given that ASR 1-best output is likely to be erroneous, this serialization of the ASR and search components might result in suboptimal search accuracy. A lattice representation of the ASR output, in particular, a word-confusion network (WCN) transformation of the lattice, compactly encodes the n-best hypothesis with the flexibility of pruning alternatives at each word position. An example of a WCN is shown in Figure  3 . The weights on the arcs are to be interpreted as costs and the best path in the WCN is the lowest cost path from the start state (0) to the final state (4). Note that the 1-best path is how old is mama, while the input speech was how old is obama which also is in the WCN, but at a higher cost.    

 Representing Search Index as an FST Lucene  (Hatcher and Gospodnetic., 2004 ) is an offthe-shelf search engine that implements the TF-IDF metric. But, we have implemented our own search engine using finite-state transducers (FST) for this reason. The oracle word/phrase accuracy using nbest hypotheses of an ASR is usually far greater than the 1-best output. However, using each of the n-best (n > 1) hypothesis as a separate query to the search component is computationally sub-optimal since the strings in the n-best hypotheses usually share large subsequences with each other. The FST representation of the search index allows us to efficiently consider lattices/WCNs as input queries. The FST search index is built as follows. We index each question-answer (QA) pair from our repository ((q i , a i ), qa i for short) using the words (w q i ) in question q i . This index is represented as a weighted finite-state transducer (SearchFST) as shown in Fig-  ure 4 . Here a word w q i (e.g old) is the input symbol for a set of arcs whose output symbol is the index of the QA pairs where old appears in the question. The weight of the arc c (wq i ,q i ) is one of the similarity based weights discussed in Section 4.1. As can be seen from Figure  4 , the words how, old, is and obama contribute a score to the question-answer pair qa25; while other pairs, qa150, qa12, qa450 are scored by only one of these words. 

 Search Process using FSTs A user's speech query, after speech recognition, is represented as an FSA (either 1-best or WCN), a QueryFSA. The QueryFSA (denoted as q) is then transformed into another FSA (NgramFSA(q)) that represents the set of n-grams of the QueryFSA. Due to the arc costs from WCNs, the NgramFSA for a WCN is a weighted FSA. The NgramFSA is composed with the SearchFST and we obtain all the arcs (w q , qa wq , c (wq,qa wq ) ) where w q is a query term, qa wq is a QA index with the query term and, c (wq,qa wq ) is the weight associated with that pair. Using this information, we aggregate the weight for a QA pair (qa q ) across all query words and rank the retrieved QAs in the descending order of this aggregated weight. We select the top N QA pairs from this ranked list. The query composition, QA weight aggregation and selection of top N QA pairs are computed with finite-state transducer operations as shown in Equations 2 to 5. 3 D1 = ? 2 (N gramF SA(q) ? SearchF ST ) (2) R1 = f smbestpath(D1, 1) (3) D2 = ? 2 (N gramF SA(R1) ? SearchF ST ) (4) T opN = f smbestpath(f smdeterminize(D2), N ) (5) The process of retrieving documents using the Levenshtein-based string similarity metric can also be encoded as a composition of FSTs. 

 Experiments and Results We have a fairly large data set consisting of over a million question-answer pairs collected by harvesting the web. In order to evaluate the retrieval methods discussed earlier, we use two test sets of QA pairs: a Seen set of 450 QA pairs and an Unseen set of 645 QA pairs. The queries in the Seen set have an exact match with some question in the database, while the queries in the Unseen set may not match any question in the database exactly.  4  The questions in the Unseen set, however, like those in the Seen set, also have a human generated answer that is used in our evaluations. For each query, we retrieve the twenty most relevant QA pairs, ranked in descending order of the value of the particular metric under consideration. However, depending on whether the user query is a seen or an unseen query, the evaluation of the relevance of the retrieved question-answer pairs is different as discussed below. 5 

 Evaluation Metrics For the set of Seen queries, we evaluate the relevance of the retrieved top-20 question-answer pairs in two ways: 1. Retrieval Accuracy of Top-N results: We evaluate whether the question that matches the user query exactly is located in the top-1, top-5, top-10, top-20 or not in top-20 of the retrieved questions. 2. Coherence metric: We compute the coherence of the retrieved set as the mean of the BLEUscore between the input query and the set of top-5 retrieved questions. The intuition is that we do not want the top-5 retrieved QA pairs to distract the user by not being relevant to the user's query. For the set of Unseen queries, since there are no questions in the database that exactly match the input query, we evaluate the relevance of the top-20 retrieved question-answer pairs in the following way. For each of the 645 Unseen queries, we know the human-generated answer. We manually annotated each unseen query with the Best-Matched QA pair whose answer was the closest semantic match to the human-generated answer for that unseen query. We evaluate the position of the Best-Matched QA in the list of top twenty retrieved QA pairs for each retrieval method. 

 Results On the Seen set of queries, as expected the retrieval accuracy scores for the various retrieval techniques performed exceedingly well. The unigram based tf.idf method retrieved 93% of the user's query in the first position, 97% in one of top-5 positions and 100% in one of top-10 positions. All the other retrieval methods retrieved the user's query in the first position for all the Seen queries (100% accuracy). In Table  1 , we tabulate the results of the Coherence scores for the top-5 questions retrieved using the different retrieval techniques for the Seen set of queries. Here, the higher the n-gram the more coherent is the set of the results to the user's query. It is interesting to note that the BLEU-score and Levenshtein similarity driven retrieval methods do not differ significantly in their scores from the n-gram tf.idf based metrics. In Table  2 , we present the retrieval results using different methods on the Unseen queries. For 240 of the 645 unseen queries, the human expert found that that there was no answer in the data repository that could be considered semantically equivalent to the human-generated response to that query. So, these 240 queries cannot be answered using the current database. For the remaining 405 unseen queries, over 60% have their Best-Matched question-answer pair retrieved in the top-1 position. We expect the coverage to improve considerably by increasing the size of the QA archive.  

 Speech-driven query retrieval In Equation  6 , we show the tight integration of WCNs and SearchFST using the FST composition operation (?). ? is used to scale the weights 6 from the acoustic/language models on the WCNs against the weights on the SearchFST. As before, we use Equation 3 to retrieve the top N QA pairs. The tight integration is expected to improve both the ASR and Search accuracies by co-constraining both components. D = ? 2 (U nigrams(W CN ) ? ?SearchF ST ) (6) For this experiment, we use the speech utterances corresponding to the Unseen set as the test set. We use a different set of 250 speech queries as the development set. In Table  3 , we show the Word and Sentence Accuracy measures for the best path in the WCN before and after the composition of SearchFST with the WCN on the development and test sets. We note that by integrating the constraints from the search index, the ASR accuracies can be improved by about 1% absolute. Since we have the speech utterances of the Unseen set, we were also able to compute the search results obtained by integrating the ASR WCNs with the SearchFST, as shown in line 5 of Table  2 . These results show that the the integration of the ASR WCNs with the SearchFST produces higher search accuracy compared to ASR 1-best. 

 Dynamic and Static Questions Storing previously answered questions and their answers allows Qme!to retrieve the answers to a subclass of questions quickly and accurately. We term this subclass as static questions since the answers to these questions remain the same irrespective of when and where the questions are asked. Examples of such questions are What is the speed of light?, When is George Washington's birthday?. In contrast, there is a subclass of questions, which we term dynamic questions, for which the answers depend on when and where they are asked. For such questions the above method results in less than satisfactory and sometimes inaccurate answers. Examples of such questions are What is the stock price of General Motors?, Who won the game last night?, What is playing at the theaters near me?. We define dynamic questions as questions whose answers change more frequently than once a year. In dynamic questions, there may be no explicit reference to time, unlike the questions in the TERQAS corpus  (Radev and Sundheim., 2002)  which explicitly refer to the temporal properties of the entities being questioned or the relative ordering of past and future events. The time-dependency of a dynamic question lies in the temporal nature of its answer. For example, consider the dynamic question, "What is the address of the theater 'White Christmas' is playing at in New York?". White Christmas is a seasonal play that plays in New York every year for a few weeks in December and January, but it does not necessarily at the same theater every year. So, depending when this question is asked, the answer will be different. Interest in temporal analysis for questionanswering has been growing since the late 1990's. Early work on temporal expressions identification using a tagger led to the development of TimeML  (Pustejovsky et al., 2001) , a markup language for annotating temporal expressions and events in text. Other examples include QA-by-Dossier with Constraints  (Prager et al., 2004) , a method of improving QA accuracy by asking auxiliary questions related to the original question in order to temporally verify and restrict the original answer.  (Moldovan et al., 2005)  detect and represent temporally related events in natural language using logical form representation.  (Saquete et al., 2009)  use the temporal relations in a question to decompose it into simpler questions, the answers of which are recomposed to produce the answers to the original question. 

 Dynamic/Static Classification We automatically classify questions as dynamic and static questions. Answers to static questions can be retrieved from the QA archive. To answer dynamic questions, we query the database(s) associated with the topic of the question through web forms on the Internet. We use a topic classifier to detect the topic of a question followed by a dynamic/static classifier trained on questions related to a topic, as shown in figure  5 . Given the question what movies are playing around me?, we detect it is a movie related dynamic question and query a movie information web site (e.g. www.fandango.com) to retrieve the results based on the user's GPS information. We used supervised learning to train the topic classifier, since our entire dataset is annotated by human experts with topic labels. In contrast, to train a dynamic/static classifier, we experimented with the following three different techniques. Baseline: We treat questions as dynamic if they contain temporal indexicals, e.g. today, now, this week, two summers ago, currently, recently, which were based on the TimeML corpus. We also included spatial indexicals such as here, and other substrings such as cost of and how much is. A question is considered static if it does not contain any such words/phrases. Self-training with bagging: The general selftraining with bagging algorithm  (Banko and Brill, 2001)  is presented in Table  6  and illustrated in  Figure 7(a) . The benefit of self-training is that we can build a better classifier than that built from the small seed corpus by simply adding in the large unlabeled corpus without requiring hand-labeling.  In order to prevent a bias towards the majority class, in step 4, we ensure that the distribution of the static and dynamic questions remains the same as in the annotated seed corpus. The benefit of bagging  (Breiman, 1996)  is to present different views of the same training set, and thus have a way to assess the certainty with which a potential training instance can be labeled. Active-learning: This is another popular method for training classifiers when not much annotated data is available. The key idea in active learning is to annotate only those instances of the dataset that are most difficult for the classifier to learn to classify. It is expected that training classifiers using this method shows better performance than if samples were chosen randomly for the same human annotation effort. Figure  7 (b) illustrates the algorithm and Figure  8  describes the algorithm, also known as committeebased active-learning  (Banko and Brill, 2001) .  We used the maximum entropy classifier in Llama  (Haffner, 2006)  for all of the above classification tasks. 

 Experiments and Results 

 Topic Classification The topic classifier was trained using a training set consisted of over one million questions downloaded from the web which were manually labeled by human experts as part of answering the questions. The test set consisted of 15,000 randomly selected questions. Word trigrams of the question are used as features for a MaxEnt classifier which outputs a score distribution on all of the 104 possible topic labels. The error rate results for models selecting the top topic and the top two topics according to the score distribution are shown in Table  4 . As can be seen these error rates are far lower than the baseline model of selecting the most frequent topic.    

 Dynamic/static Classification As mentioned before, we experimented with three different approaches to bootstrapping a dynamic/static question classifier. We evaluate these methods on a 250 question test set drawn from the broad topic of Movies. For the baseline model, we used the words/phrases discussed earlier based on temporal and spatial indexicals.  In the self-training approach, we start with a small seed corpus of 250 hand-labeled examples from the Movies topic annotated with dynamic or static tags. We used the same set of 500K unlabeled examples as before and word trigrams from the question were used as the features for a MaxEnt classifier. We used 11 bags in the bagging phase of this approach and required that all 11 classifiers agree unanimously about the label of a new instance. Of all such instances, we randomly selected N instances to be added to the training set of the next iteration, while maintaining the distribution of the static and dynamic questions to be the same as that in the seed corpus. We experimented with various values of N , the number of newly labeled instances added at each iteration. The error rate at initialization is 10.4% compared to 22.1% of the "supervised" approach which can be directly attributed to the 250 handlabeled questions. The lowest error rate of the selftraining approach, obtained at N=100, is 8.84%, as shown in Table  5 . In Figure  9 , we show the change in error rate for N=40 (line S1 in the graph) and N=100 (line S2 in the graph). For the active learning approach, we used the same set of 250 questions as the seed corpus, the same set of 500K unlabeled examples, the same test set, and the same set of word trigrams features as in the self-training approach. We used 11 bags for the bagging phase and selected top 20 new unlabeled instances on which the 11 classifiers had the greatest vote entropy to be presented to the human labeler for annotation. We also randomly selected 20 instances from the rest of the unlabeled set to be presented for annotation. The best error rate of this classifier on the test set is 4.02%, as shown in Table  5 . The error rate over successive iterations is shown by line A1 in Figure  9 . In order to illustrate the benefits of selecting the examples actively, we repeated the experiment described above but with all 40 unlabeled instances selected randomly for annotation. The error rate over successive iterations is shown by line R1 in Figure  9 . Comparing A1 to R1, we see that the error decreases faster when we select some of the unlabeled instances for annotation actively at each iteration. 

 Conclusion In this paper, we have presented a system Qme!, a speech-driven question-answering system for mobile devices. We have proposed a query retrieval model for question-answering and demonstrated the mutual benefits of tightly coupling the ASR and Search components of the system. We have presented a novel concept of distinguishing questions that need dynamic information to be answered from those questions whose answers can be retrieved from an archive. We have shown results on bootstrapping such a classifier using semi-supervised learning techniques. Figure 1 : 1 Figure 1: The architecture of the speech-driven questionanswering system 
