title
Combining Generative and Discriminative Approaches to Unsupervised Dependency Parsing via Dual Decomposition *

abstract
Unsupervised dependency parsing aims to learn a dependency parser from unannotated sentences. Existing work focuses on either learning generative models using the expectation-maximization algorithm and its variants, or learning discriminative models using the discriminative clustering algorithm. In this paper, we propose a new learning strategy that learns a generative model and a discriminative model jointly based on the dual decomposition method. Our method is simple and general, yet effective to capture the advantages of both models and improve their learning results. We tested our method on the UD treebank and achieved a state-ofthe-art performance on thirty languages.

Introduction Dependency parsing is an important task in natural language processing. It identifies dependencies between words in a sentence, which have been shown to benefit other tasks such as semantic role labeling  (Lei et al., 2015)  and sentence classification  (Ma et al., 2015) . Supervised learning of a dependency parser requires annotation of a training corpus by linguistic experts, which can be time and resource consuming. Unsupervised dependency parsing eliminates the need for dependency annotation by directly learning from unparsed text. Previous work on unsupervised dependency parsing mainly focuses on learning generative models, such as the dependency model with valence (DMV)  (Klein and Manning, 2004 ) and combinatory categorial grammars (CCG)  (Bisk and Hockenmaier, 2012) . Generative models have many advantages. For example, the learning objective function can be defined as the marginal likelihood of the training data, which is typically easy to compute in a generative model. In addition, many types of inductive bias, such as those favoring short dependency arcs  (Smith and Eisner, 2006) , encouraging correlations between POS tags  (Cohen et al., 2008; Cohen and Smith, 2009; Berg-Kirkpatrick et al., 2010; Jiang et al., 2016) , and limiting center embedding  (Noji et al., 2016) , can be incorporated into generative models to achieve better parsing accuracy. However, due to the strong independence assumption in most generative models, it is difficult for these models to utilize context information that has been shown to benefit supervised parsing. Recently, a feature-rich discriminative model for unsupervised parsing is proposed that captures the global context information of sentences  (Grave and Elhadad, 2015) . Inspired by discriminative clustering, learning of the model is formulated as convex optimization of both the model parameters and the parses of training sentences. By utilizing language-independent rules between pairs of POS tags to guide learning, the model achieves state-ofthe-art performance on the UD treebank dataset. In this paper we propose to jointly train two state-of-the-art models of unsupervised dependency parsing: a generative model called LC-DMV  (Noji et al., 2016 ) and a discriminative model called Convex-MST  (Grave and Elhadad, 2015) . We employ a learning algorithm based on the dual decomposition (Dantzig and Wolfe, 1960) inference algorithm, which encourages the two models to influence each other during training. We evaluated our method on thirty languages and found that the jointly trained models surpass their separately trained counterparts in parsing accuracy. Further analysis shows that the two models positively influence each other during joint train-ing by implicitly sharing the inductive bias. 

 Preliminaries 

 DMV The dependency model with valence (DMV)  (Klein and Manning, 2004)  is the first generative model that outperforms the left-branching baseline in unsupervised dependency parsing. In D-MV, a sentence is generated by recursively applying three types of grammar rules to construct a parse tree from the top down. The probability of the generated sentence and parse tree is the probability product of all the rules used in the generation process. To learn the parameters (rule probabilities) of DMV, the expectation maximization algorithm is often used.  Noji et al. (2016)  exploited two universal syntactic biases in learning DMV: restricting the center-embedding depth and encouraging short dependencies. They achieved a comparable performance with state-of-the-art approaches. 

 Convex-MST Convex-MST  (Grave and Elhadad, 2015)  is a discriminative model for unsupervised dependency parsing based on the first-order maximum spanning tree dependency parser  (McDonald et al., 2005) . Given a sentence, whether each possible dependency exists or not is predicted based on a set of handcrafted features and a valid parse tree closest to the prediction is identified by the minimum spanning tree algorithm. For each sentence x, a first-order dependency graph is built over the words of the sentence. The weight of each edge is calculated by w T f (x, i, j), where w is the parameters and f (x, i, j) is the handcrafted feature vector of the dependency from the i-th word to the j-th word in sentence x. For sentence x of length n, we can represent it as matrix X where each raw is a feature vector. The parse tree y is a spanning tree of the graph and can be represented as a binary vector with length n?n where each element is 1 if the corresponding arc is in the tree and 0 otherwise. Learning is based on discriminative clustering with the following objective function: 1 N N ?=1 1 2n ? ||y ? ? X ? w|| 2 2 ? ?v T y ? + ? 2 ||w|| 2 2 where X ? is a matrix where each row is a feature representation f (x ? , i, j) of an edge in the depen-dency graph of sentence x ? , v represents whether each dependency arc in y ? satisfies a set of prespecified linguistic rules, and ? and ? are hyperparameters. The Frank-Wolfe algorithm is employed to optimize the objective function. 

 Dual Decomposition Dual decomposition (Dantzig and Wolfe, 1960), a special case of Lagrangian relaxation, is an optimization method that decomposes a hard problem into several small sub-problems. It has been widely used in machine learning  (Komodakis et al., 2007)  and natural language processing  (Koo et al., 2010; Rush and Collins, 2012) .  Komodakis et al. (2007)  proposed using dual decomposition to do MAP inference for Markov random fields.  Koo et al. (2010)  proposed a new dependency parser based on dual decomposition by combining a graph based dependency model and a non-projective head automata. In the work of , they showed that dual decomposition can effectively integrate two lexicalized parsing models or two correlated tasks. 

 Agreement based Learning Liang et al.  (2008)  proposed agreement based learning that trains several tractable generative models jointly and encourages them to agree on certain latent variables. To effectively train the system, a product EM algorithm was used. They showed that the joint model can perform better than each independent model on the accuracy or convergence speed. They also showed that the objective function of the work of  Klein and Manning (2004)  is a special case of the product EM algorithm for grammar induction. Our approach has a similar motivation to agreement based learning but has two important advantages. First, while their approach only combines generative models, our approach can make use of both generative and discriminative models. Second, while their approach requires the sub-models to share the same dynamic programming structure when performing decoding, our approach does not have such restriction. 

 Joint Training We minimize the following objective function that combines two different models of unsupervised dependency parsing: J(M F , M G ) = N ?=1 min y?Y? (F (x ? , y ? ; M F ) + G(x ? , y ? ; M G )) where N is the size of training data, M F and M G are the parameters of the first and second model respectively, F and G are their respective learning objectives, and Y ? is the set of valid dependency parses of sentence x ? . While in principle this objective can be used to combine many different types of models, here we consider two state-of-the-art models of unsupervised dependency parsing, a generative model LC-DMV  (Noji et al., 2016 ) and a discriminative model Convex-MST  (Grave and Elhadad, 2015) . We denote the parameters of LC-DMV by ? and the parameters of Convex-MST by w. Their respective objective functions are, F (x ? , y ? ; ?) = ? log (P ? (x ? , y ? )f (x ? , y ? )) G(x ? , y ? ; w) = 1 2n ? ||y ? ? X ? w|| 2 2 + ? 2N ||w|| 2 2 ? ?v T y where P ? (x ? , y ? ) is the joint probability of sentence x ? and parse y ? , f is a constraint factor, and the notations in the second objective function are explained in section 2.2. 

 Learning We use coordinate descent to optimize the parameters of the two models. In each iteration, we first fix the parameters and find the best dependency parses of the training sentences (see section 3.2); we then fix the parses and optimize the parameters. The detailed algorithm is shown in Algorithm 1. Pretraining of the two models is done by running their original learning algorithms separately. When the parses of the training sentences are fixed, it is easy to show that the parameters of the two models can be optimized separately. Updating the parameters ? of LC-DMV can be done by simply counting the number of times each rule is used in the parse trees and then normalizing the counts to get the maximum-likelihood probabilities. The parameters w of Convex-MST can be updated by stochastic gradient descent. After updating ? and w at each iteration, we additionally train each model separately for three iterations, which we find further improves learning. We employ the dual decomposition algorithm to solve this problem (shown in Algorithm 2), where ? represents the step size. The most important part of the algorithm is solving the two separate decoding problems: ? = arg min y?Y ? log(P ? (x, y)f (x, y)) + u T y ? = arg min z?Y 1 2n ||z ? Xw|| 2 2 ? ?v T z ? u T z The first decoding problem can be solved by a modified CYK parsing algorithm that takes into account the information in vector u. The second decoding problem can be solved using the same algorithm of  Grave and Elhadad (2015)  (we use the projective version in our approach). 

 Experiments 

 Setup We use UD Treebank 1.4 as our datasets. We sorted the datasets in the treebank by the number of training sentences of length ? 15 and selected the top thirty datasets, which is similar to the setup of  Noji et al. (2016) . For each dataset, we trained our method on the training data with length ? 15 and tested our method on the testing data with length ? 40. We tuned the hyper-parameters of our method on the dataset of the English language and reported the results on the thirty datasets without any further parameter tuning. We compared our method with four baselines. The first two baselines are Convex-MST and LC-DMV that are independently trained. To construct the third baseline, we used the independently trained Convex-MST baseline to parse all the training sentences and then used the parses to initialize the training of LC-DMV. This can be seen as a simple method to combine two different approaches. On the other hand, we did not use the LC-DMV baseline to initialize Convex-MST training because the objective function of Convex-MST is convex and therefore the initialization does not matter. 

 Results In Table  1 , we compare our jointly trained models with the four baselines. We can see that with joint training and independent decoding, LC-DMV and Convex-MST can achieve superior overall performance than when they are separately trained with or without mutual initialization. Joint decoding with our jointly trained models performs worse than independent decoding. We made the same observation when applying joint decoding to the separately trained models (not shown in the table  ) . We believe this is because unsupervised parsers have relatively low accuracy and forcing them to reconcile would not lead to better parses. On the other hand, joint decoding during training helps propagate useful inductive biases between models and thus leads to better trained models. 

 Analysis of Parsing Results We analyze the parsing results from the two models to see how they benefit each other with joint training. Note that LC-DMV limits the depth of center embedding and encourages shorter dependency length, while Convex-MST encourages dependencies satisfying pre-specified linguistic rules. Therefore, we would like to see whether the jointly-trained LC-DMV produces more dependencies satisfying the linguistic priors than its separately-trained counterpart, and whether the jointly-trained Convex-MST produces parse trees  with less center embedding and shorter dependencies than its separately-trained counterpart. Figure  1  shows the percentages of dependencies satisfying linguistic rules when using the separately and jointly trained LC-DMV to parse the test sentences in the English dataset. As we can see, with joint training, LC-DMV is indeed influenced by Convex-MST and produces more dependencies satisfying linguistic rules. Table  2  shows the average dependency length when using the separately and jointly trained Convex-MST to parse the English test dataset. The dependency length can be seen to decrease with joint training, showing the influence from LC-DMV. As to center embedding depth, we find that separately trained Convext-MST already produces very few center embeddings of depth 2 or more, Algorithm 1 1 Parameter Learning Input: Training sentence x 1 , x 2 , ..., x N Pre-train ? and w repeat Fix ? and w and solve the decoding problem to get y ? , ? = 1, 2, . . . , N Fix the parses and update ? and w until Convergence Algorithm 2 Decoding via Dual Decomposition Input: Sentence x, fixed parameters w and ? Initialize vector u of size n ? n to 0 repeat ? = arg min y?Y F (x, y; ?) + u T y ? = arg min z?Y G(x, z; w) ? u T z if ? = ? then return ? else u = u ? ? (? ? ?) end if until Convergence3.2 Joint DecodingGiven a training sample x and parameters w, ?, the goal of decoding is to find the best parse tree: T y?log P ? (x, y) 

 sentences of length ? 40. The last row indicates the average directed accuracy on sentences of length ? 15. M (Convex-MST) and D (LC-DMV) are the independently trained baselines. D-I is the third baseline in which the LC-DMV training is initialized by the parses produced from the trained Convex-MST model. With our jointly trained models, M-J and D-J denote separate decoding and DD denotes joint decoding. 

 Table 1 : 1 Directed dependency accuracy on thirty datasets with test Language M D D-I M-J D-J DD A Greek 43.4 33.1 38.8 44.2 44.9 38.9 A Greek-P 50.4 43.0 44.7 50.8 52.9 44.9 Basque 50.0 45.4 54.2 52.1 55.7 50.2 Bulgarian 61.6 62.4 60.3 64.7 73.8 64.8 Czech 48.6 17.4 53.9 48.7 54.0 53.5 Czech-CAC 50.4 53.0 53.9 55.6 62.3 50.2 Dutch 45.3 34.1 56.7 48.2 43.5 40.7 Dutch-LS 42.4 27.0 16.4 43.2 41.2 36.3 English 54.0 56.0 49.8 57.3 60.1 53.4 Estonian 49.4 31.8 47.5 48.7 44.0 44.4 Finnish 44.7 26.9 39.0 44.2 43.5 31.2 Finnish-FTB 49.9 31.0 47.9 47.7 48.0 36.5 French 62.0 48.6 57.0 54.5 57.0 55.5 German 51.4 50.5 54.1 49.3 55.7 48.6 Gothic 52.7 49.9 47.3 59.6 56.4 58.0 Hindi 56.8 54.2 48.4 52.1 60.0 49.1 Italian 69.1 71.1 67.4 62.8 70.3 64.5 Japanese 44.8 43.8 43.8 42.8 45.8 41.0 Latin-ITTB 38.8 38.6 42.3 47.0 42.2 40.3 Latin-PROIEL 44.3 34.8 38.7 46.8 41.8 42.9 Norwegian 55.3 45.5 51.4 57.4 60.8 46.6 Old Church S 56.4 26.6 51.3 58.3 58.6 42.0 Polish 63.4 63.7 61.5 70.7 74.2 68.9 Portuguese 57.9 67.2 60.1 56.1 62.9 57.4 Portuguese-BR 59.3 63.1 62.0 65.5 68.8 58.3 Russian-STR 47.6 51.7 56.5 52.1 64.4 52.6 Slovak 57.4 59.3 51.9 61.7 65.9 58.7 Slovenian 54.0 49.5 56.3 65.5 69.6 56.1 Spanish 61.9 61.9 60.3 57.4 68.0 60.2 Spanish-AC 59.4 59.5 56.4 56.8 65.2 57.6 Average 52.7 47.2 50.3 54.2 56.5 49.6 Average ? 15 55.4 48.9 54.9 57.3 60.2 53.8
