title
Parsing Gapping Constructions Based on Grammatical and Semantic Roles

abstract
A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts. This paper proposes a method of parsing sentences with gapping to recover elided elements. The proposed method is based on constituent trees annotated with grammatical and semantic roles that are useful for identifying elided elements. Our method outperforms the previous method in terms of F-measure and recall.

Introduction A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts. For example, we can elide the second redundant verb "ate" from the sentence "John ate bread, and Mary ate rice." We need to recover elided elements to interpret sentences with gapping; however, little work has focused on developing such methods. This paper proposes a method of parsing sentences with gapping. Our proposed method uses constituent trees annotated with grammatical and semantic tags and a special tag indicating gapped conjuncts. The method parses a sentence to obtain a tag-annotated constituent tree and analyzes gapping constructions using the resulting tree when it includes gapped conjuncts. The analysis is based on a sequence alignment algorithm using grammatical and semantic tags. An experiment shows that our method outperforms the previous method in terms of F-measure and recall. 

 Gapping Construction This section first explains gapping constructions in the Penn Treebank (PTB,  Marcus et al., 1993) , on which our proposed method is based, and summarizes the previous work on analyzing sentences with gapping. 

 Gapping Constructions in the PTB A gapping construction consists of a coordinated structure where redundant elements are elided from all but one conjuncts. The constituents remaining in a gapped conjunct are called remnants. The remnants have a corresponding constituent, called a correlate, in the ungapped conjunct.  1  We can obtain the ungapped version of the conjunct by replacing each correlate with its corresponding remnant. In the PTB, the correspondences between remnants and correlates are annotated. Figure  1  shows an example of a PTB constituent tree, which includes a gapping construction. The nodes marked with "-" hyphen indices are the correlates, while those marked with "=" equal indices are the remnants. A gapped conjunct is flattened, that is, all remnants are children of the conjunct node. The number assigned to a correlate and a remnant indicates a correspondence relation. For example, NP-SBJ-1 and NP-SBJ=1 in this tree are a correlate and a remnant, respectively, and correspond to each other. We can obtain the constituent tree for "the six-month bills will still mature on May 3, 1990" by replacing NP-SBJ-1 with the tree whose root is NP-SBJ=1 and NP-TMP-2 with that whose root is PP-TMP=2. In other words, "will still mature" is elided from the second conjunct. 

 Previous Work This section gives an overview of previous approaches to analyzing sentences with gapping.  Ficler and Goldberg (2016)  proposed a new representation for argument-cluster coordination, which is one kind of gapping constructions. They converted PTB trees by coordinating correlates and remnants. This conversion can be applied only when the correlates and the remnants are all to- gether on the right. Therefore, it cannot handle the tree shown in Figure  1 .  Kummerfeld and Klein (2017)  developed a parser that adopts a graph representation for syntactic structure. They discussed how to represent a correspondence between a remnant and a correlate with an arc in their graph representation. However, the parser struggled to generate such arcs, and the recall was very low.  2  Schuster  et al. (2018)  proposed two methods based on dependency structure. One represents gapping constructions using complex relation labels  (Seeker et al., 2012) , and the other adopts a sequence alignment algorithm to assign remnant words to correlate words. The latter is similar to ours. We will discuss the differences between the latter method and ours in the later section. Another approach is the one that does not depend on syntactic representation. In the Automatic Gapping Resolution Shared Task for Russian (AGRR-2019)  (Ponomareva et al., 2019) , the prepared dataset marked each element comprising gapping constructions. Most participants treated this task as a sequence labeling problem. 

 Proposed Method This section describes our proposed method, which parses gapping constructions. Our method enables existing PTB-based parsers to identify correspondences between correlates and remnants. Elided elements can be recovered by such correspondences as described in Section 2.1. One difficulty in parsing gapping constructions is insufficient data for modeling such phenomena because their occurrence is rare. To mitigate this problem, our method learns not directly from correspondences between correlates and remnants, but from the following tags easily obtained from the PTB: ? a special tag indicating gapped conjuncts 

 ? grammatical and semantic role tags Correspondences between correlates and remnants are identified by a sequence alignment algorithm using the tag-annotated constituent tree. We first explain our tag annotation and describe the sequence alignment algorithm. 

 Annotation Our method uses a special tag to identify gapped conjuncts in constituency parsing. Specifically, we assign the GAP tag to a node n, if n satisfies the following condition: ? n has a child marked with "=" index. In the coordinated structure shown in Figure  1 , the GAP tag is assigned to the second S conjunct node. Next, we explain grammatical and semantic tags. In general, each remnant and its corresponding correlate play an identical grammatical or semantic role. For example, in Figure  1 , the constituents co-indexed with 1 are subjects (SBJ), while those co-indexed with 2 are temporal adjuncts (TMP). This fact suggests that correspondences between correlates and remnants can be identified using grammatical and semantic roles. Our method directly uses the PTB grammatical and semantic role tags shown in Table  1 .  3  An important point herein is that our method has an advantage from the viewpoint of training data. The PTB includes a massive amount of grammatical and semantic tag information; thus, we can learn a model that identifies the tags by simply retaining them in the treebank  (Gabbard et al., 2006) . 

 How to identify correspondences between correlates and remnants This section explains how to identify correspondences between correlates and remnants using the tag-annotated constituent trees described in the previous section. The procedure consists of the following two steps: 1. Extract remnant candidates R and correlate candidates C when gapped conjuncts exist. 

 Align nodes in R to nodes in C. The first step is invoked if a node n g annotated with the GAP tag exists. A set R of remnant candidates is defined as a set of n g 's children. To extract the correlate candidates C, the method seeks the ungapped conjunct n u that satisfies the following condition: n u ? L(n g ) ? ct(n u ) = ct(n g ) ? ?n ? L(n u ) ( ct(n) = ct(n u ) ) where, L(n) and ct(n) are the set of left siblings of n and the category of n, respectively. A set C of correlate candidates is defined as a set of n u 's proper descendants. The second step aligns nodes in R to nodes in C. Here we impose a constraint that r ? R plays an identical role to c ? C. More precisely, we can align r to c if the following condition holds: match(c, r) def = ( rl(c) = rl(r) ? = null ) ? ( ct(c) = ct(r) = PP ? hd(c) = hd(r) ) ? ( rl(c) = rl(r) = null ? ct(c) = ct(r) ) where, rl(x) stands for the role tag of x. If x has no role tag, rl(x) = null. hd(x) is the head preposition of x. Furthermore, we impose the following structural constraints to follow the PTB annotation scheme: Uniqueness of remnant If (c, r) ? A and (c, r ? ) ? A, then r = r ? . Uniqueness of correlate If (c, r) ? A and (c ? , r) ? A, then c = c ? . Order-Preserving For all (c, r), (c ? , r ? ) ? A, if e(r) ? s(r ? ), then e(c) ? s(c ? ). Non-overlapping For all (c, r), (c ? , r ? ) ? A(c ? = c ? ), then e(c) ? s(c ? ) or e(c ? ) ? s(c). Here, A ? C ? R is a set representing an alignment of correlates to remnants. (c, r) ? A means that a correlate c is aligned to a remnant r. s(n) and e(n) stand for the start and end positions of node n, respectively. 

 DP-based sequence alignment To realize the second step described in Section 3.2, we modify the sequence alignment algorithm proposed by  Needleman and Wunsch (1970) . T[i, n] ? ?{}, 0? 4: end for 5: for j = 0 to n do 6: T[m, j] ? ?{}, 0? 7: end for 8: for i = m ? 1 down to 0 do 9: for j = n ? 1 down to 0 do 10: ?A, s? ? T[skip-des[i], j + 1] 11: Match ? ?A ? {(ci, rj)}, s + score(ci, rj)? 12: T[i, j] ? arg max T ?{T[i+1,j],T[i,j+1],Match} Score(T ) 13: end for 14: end for 15: return T [0, 0] 

 Discussion Our method is similar to that of  Schuster et al. (2018)  in that both rely on sequence alignment. The following differences, however, exist: ? The previous method converts Universal Dependencies (UD) v2 representations  (Nivre et al., 2017)  to enhanced UD representations  (Schuster and Manning, 2016) , which provides an analysis of gapping constructions. It cannot use grammatical and semantic roles unlike ours, because remnants cannot have such information in the UD v2 framework. 6 ? Our proposed sequence alignment algorithm is a novel one that can impose the orderpreserving and non-overlapping constraints on the resulting alignment. This feature is required to deal with gapping constructions in PTB constituent trees. 

 Experiment We conducted an experiment using the PTB to evaluate the performance of our proposed method.  7  We used the standard PTB training, development, and test data split (i.e., sections 02-21, 22, and 23, respectively) and the Kitaev and Klein parser  (Kitaev and Klein, 2018)  8 that can use BERT  (Devlin et al., 2019)  development data with those annotated by our annotation scheme. The hyperparameters were identical to those of  Kitaev et al. (2019) . The test data were parsed by the trained model to obtain tagannotated trees. The correspondences between the correlates and the remnants were identified by our proposed alignment algorithm. The alignment accuracy was evaluated by the metric of Kummerfeld and Klein (2017). That is, we represent a correspondence between a correlate c and a remnant r as a tuple (ct(r), s(r), e(r), ct(c), s(c), e(c)), and measure the precision and recall using tuples. Table  2  shows the alignment performance of our method and the previous one. The previous method struggled to generate arcs between correlates and remnants and had a very low recall. In contrast, our method achieved high recall and F-measure. It outperformed the previous method even without BERT. The last row in Table  2  shows the performance when using gold tag-annotated trees, indicating that our sequence alignment algorithm works well and that tag identification directly affects the overall performance. We evaluated the tag identification accuracy using a tuple (rl(n), s(n), e(n)). Table  3  presents the tag identification accuracy. The performance of identifying grammatical and semantic tags did not differ much between using BERT and not using BERT. On the other hand, the performance of identifying the GAP tag without BERT is rather low compared to that with BERT. Therefore, the main reason for the low performance of the alignment without BERT is the degraded performance of identifying the GAP tag. Finally, we report the constituency parsing performance. Table  4  shows the accuracy of the Kitaev and Klein parser with and without our tag annotation. The result implies that our tag annotation to constituent trees has a tiny negative impact on the constituency parsing performance. 

 Conclusion This paper has proposed a method of parsing gapping constructions based on tag-annotated constituent trees. Our proposed method is simple but effective. We believe that it will serve as a strong baseline for the task of parsing gapping constructions. In the future work, we will extend our method by replacing the simple role matching score with grammatical or semantic similaritybased measures to improve the alignment accuracy. Figure 1 : 1 Figure 
