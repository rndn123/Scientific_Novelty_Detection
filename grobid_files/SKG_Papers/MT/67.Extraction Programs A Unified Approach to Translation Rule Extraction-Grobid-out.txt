title
Extraction Programs: A Unified Approach to Translation Rule Extraction

abstract
We provide a general algorithmic schema for translation rule extraction and show that several popular extraction methods (including phrase pair extraction, hierarchical phrase pair extraction, and GHKM extraction) can be viewed as specific instances of this schema. This work is primarily intended as a survey of the dominant extraction paradigms, in which we make explicit the close relationship between these approaches, and establish a language for future hybridizations. This facilitates a generic and extensible implementation of alignment-based extraction methods.

Introduction The tradition of extracting translation rules from aligned sentence pairs dates back more than a decade. A prominent early example is phrase-based extraction  (Och et al., 1999) . Around the middle of the last decade, two extraction paradigms were proposed for syntax-based machine translation: the Hiero paradigm of  (Chiang, 2005)  and the GHKM paradigm of  (Galley et al., 2004) . From these papers followed two largely independent lines of research, respectively dubbed formally syntax-based machine translation  (Chiang, 2007; Zollmann and Venugopal, 2006; Venugopal et al., 2007; Lopez, 2007; Marton and Resnik, 2008; Li et al., 2009; de Gispert et al., 2010)  and linguistically syntax-based machine translation  (Galley et al., 2006; Liu et al., 2006; Huang et al., 2006; Liu et al., 2007; Mi and Huang, 2008; Zhang et al., 2008; Liu et al., 2009) . In this paper, we unify these strands of research by showing how to express Hiero extraction, GHKM extraction, and phrase-based extraction as instances of a single master extraction method. Specifically, we express each technique as a simple "program" given to a generic "evaluator". Table  1  summarizes how to express several popular extraction methods as "extraction programs." Besides providing a unifying survey of popular alignment-based extraction methods, this work has the practical benefit of facilitating the implementation of these methods. By specifying the appropriate input program, the generic evaluator (coded, say, as a Python module) can be used to execute any of the extraction techniques in Table  1 . New extraction techniques and hybridizations of existing techniques can be supported with minimal additional programming. 

 Building Blocks The family of extraction algorithms under consideration share a common setup: they extract translation rules from a sentence pair and an alignment. In this section, we define these concepts. 

 Patterns and Sentences Assume we have a global vocabulary of atomic symbols, containing the reserved substitution symbol ?. Define a pattern as a sequence of symbols. Define the rank of a pattern as the count of its ? symbols. Let ? k k ?, ?, ..., ? . We will typically use space-delimited quotations to represent example patterns, e.g. "ne ? pas" rather than ne, ?, pas . We will use the dot operator to represent the concatenation of patterns, e.g. "il ne" ? "va pas" = "il ne va pas". 

 Extraction Program Method Primary Secondary Labeling Protocol Protocol Protocol PBMT  (Och et al., 1999)  RANKPP 0 TRIVSP A TRIVLP Hiero  (Chiang, 2005)  RANKPP ? TRIVSP A TRIVLP GHKM  (Galley et al., 2004)  MAPPP t TRIVSP A PMAPLP t SAMT  (Zollmann and Venugopal, 2006)  RANKPP ? TRIVSP A PMAPLP t Forest GHKM  (Mi and Huang, 2008)  MAPPP T TRIVSP A PMAPLP T Tree-to-Tree GHKM  (Liu et al., 2009)  MAPPP t MAPSP ?,A IMAPLP {t},{? } Forest-to-Forest GHKM  (Liu et al., 2009)  MAPPP T MAPSP T ,A IMAPLP T,T Fuzzy Dual Syntax  (Chiang, 2010)  MAPPP t MAPSP ? ,A IMAPLP { t},{? } We refer to a contiguous portion of a pattern with a span, defined as either the null span ? , or a pair Finally, define a sentence as a pattern of rank 0. 

 Alignments An alignment is a triple m, n, A , where m and n are positive integers, and A is a set of ordered integer pairs (i, j) such that 1 ? i ? m and 1 ? j ? n. In Figure  1 (a), we show a graphical depiction of alignment 4, 6, {(1, 1), (2, 3), (4, 3), (3, 5)} . Observe that alignments have a primary side (top) and a secondary side (bottom) 1 . For alignment A = m, n, A , define |A| p = m and |A| s = n. A primary index (resp., secondary index) of A is any positive integer less than or equal to |A| p (resp., |A| s ). A primary span (resp., secondary span) of A is any span [b, c] such that 1 ? b ? c ? |A| p (resp., |A| s ). Define a A ? ? to mean that (a, ?) ? A (in words, we say that A aligns primary index a to secondary  1  The terms primary and secondary allow us to be agnostic about how the extracted rules are used in a translation system, i.e. the primary side can refer to the source or target language. index ?), and define a A ? ? to mean that (a, ?) ? A. Define an aligned sentence pair as a triple s, ?, A where A is an alignment and s, ? are sentences of length |A| p and |A| s , respectively. Primary and Secondary Domain: The primary domain of alignment A is the set of primary indices that are aligned to some secondary index, i.e. Consider Figure  1(d ). We will also allow a more relaxed type of projection, in which we allow the broadening of the minimal projection to include unaligned secondary indices. In the example, secondary spans [2, 5],  [3, 6] , and [2, 6] (in addition to the minimal projection  [3, 5] ) are all considered projections of primary span  [2, 4] . Formally, de- fine pproj A ([b, c]) as the set of superspans [?, ?] of pmproj A ([b, c]) such that [?, ?] ? sdom(A) ? pmproj A ([b, c]). 

 Rules We define an unlabeled rule as a tuple k, s * , ? * , ? where k is a nonnegative integer, s * and ? * are patterns of rank k, and ? is a permutation of the sequence 1, 2, ..., k . Such rules can be rewritten using a more standard Synchronous Context-Free Grammar (SCFG) format, e.g. 3, "le ? ? de ?", "? 's ? ?", 3, 2, 1 can be written: ? ? le ? 1 ? 2 de ? 3 , ? 3 's ? 2 ? 1 . A labeled rule is a pair r, l , where r is an unlabeled rule, and l is a "label". The unlabeled rule defines the essential structure of a rule. The label gives us auxiliary information we can use as decoding constraints or rule features. This deliberate modularization lets us unify sequence-based and treebased extraction methods. Labels can take many forms. Two examples (depicted in Figure  2 ) are: 1. An SCFG label is a (k + 1)-length sequence of symbols.  ? le ? 1 ? 2 de ? 3 , ? 3 's ? 2 ? 1 . 2. An STSG label (from Synchronous Tree Substitution Grammar  (Eisner, 2003) ) is a pair of trees. STSG labels subsume SCFG labels. Thus STSG extraction techniques can be used as SCFG extraction techniques by ignoring the extra hierarchical structure of the STSG label. Due to space constraints, we will restrict our focus to SCFG labels. When considering techniques originally formulated to extract STSG rules (GHKM, for instance), we will consider their SCFG equivalents. 

 A General Rule Extraction Schema In this section, we develop a general algorithmic schema for extracting rules from aligned sentence pairs. We will do so by generalizing the GHKM algorithm  (Galley et al., 2004) . The process goes as follows: ? Repeatedly: -Choose a "construction request," which consists of a "primary subrequest" (see Figure  3a ) and a "secondary subrequest" (see Figure  3b ). -Construct the unlabeled rule corresponding to this request (see Figure  3 , bottom). -Label the rule (see Figure  2 ).  

 Choose a Construction Request The first step in the extraction process is to choose a "construction request," which directs the algorithm about which unlabeled rule(s) we wish to construct. A "construction request" consists of two "subrequests." Subrequests: A subrequest is a nonempty sequence of non-null spans [b 0 , c 0 ], [b 1 , c 1 ], ..., [b k , c k ] such that, for all 1 ? i < j ? k, [b i , c i ] and [b j , c j ] are disjoint proper 2 subsets of [b 0 , c 0 ]. If it also true that c i < b j , for all 1 ? i < j ? k, then the subrequest is called monotonic. We refer to k as the rank of the subrequest. We typically write subrequest [b 0 , c 0 ], [b 1 , c 1 ], ..., [b k , c k ] using the notation: 2 If unary rules are desired, i.e. rules of the form ? ? ?, then this condition can be relaxed. [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] or as [b 0 , c 0 ] if k = 0. For subrequest x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ], define: covered(x) = ? k i=1 [b i , c i ] uncovered(x) = [b 0 , c 0 ]\covered(x) Primary Subrequests: Given an alignment A, define the set frontier(A) as the set of primary spans  [b, c] of alignment A such that pmproj A ([b, c])) is nonempty and disjoint from pimage A ([1, b ? 1]) ? pimage A ([c + 1, |A| p ]). 3 Algorithm CONSTRUCTRULE s,?,A (x, ?): if construction request x, ? matches alignment A then {u 1 , ..., u p } = uncovered([b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ]) {? 1 , ..., ? q } = uncovered([? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ]) s * = INDEXSORT( b 1 , b 2 , ..., b k , u 1 , u 2 , ..., u p , k ?, ?, ..., ?, s u 1 , s u 2 , ..., s up ) ? * = INDEXSORT( ? 1 , ? 2 , ..., ? k , ? 1 , ? 2 , ..., ? q , k ?, ?, ..., ?, ? ? 1 , ? ? 2 , ..., ? ?q ) ? = INDEXSORT( ? 1 , ? 2 , ..., ? k , 1, 2, ..., k ) return { k, s * , ? * , ? } else return {} end if = "? 1 ? 2 ... ? n " are sentences, A = m, n, A is an alignment, x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] and ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] are subrequests. Define preqs(A) as the set of monotonic subrequests whose spans are all in frontier(A). We refer to members of preqs(A) as primary subrequests of alignment A. Figure  3a  shows a primary subrequest of an example alignment. Secondary Subrequests: Given a primary sub- request x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] of align- ment A, define sreqs(x, A) as the set of subrequests [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] such that [? i , ? i ] ? pproj A ([b i , c i ] ), for all 0 ? i ? k. We refer to members of sreqs(x, A) as secondary subrequests of primary subrequest x and alignment A. Figure  3b  shows a secondary subrequest of the primary subrequest selected in Figure  3a . Construction Requests: A construction request is a pair of subrequests of equivalent rank. Construction request x, ? matches alignment A if x ? preqs(A) and ? ? sreqs(x, A). 

 Construct the Unlabeled Rule The basis of rule construction is the INDEXSORT operator, which takes as input a sequence of integers I = i 1 , i 2 , ..., i k , and an equivalentlength sequence of arbitrary values v 1 , v 2 , ..., v k , and returns a sequence v j 1 , v j 2 , ..., v j k , where j 1 , j 2 , ..., j k is a permutation of sequence I in ascending order. For instance, INDEX-SORT( 4, 1, 50, 2 , "a", "b", "c", "d" ) = property is a property of the alignment alone. It is independent of the auxiliary information that GHKM uses, in particular the tree. Primary Protocol RANKPP k : "b", "d", "a", "c" . Note that the output of INDEXSORT(I, V ) is nondeterministic if sequence I has repetitions. In Figure  4 , we show the pseudocode for rule construction. We show an example construction in Figure  3  (bottom). {[b 0 , c 0 ] [b 1 , c 1 ]...[b j , c j ] s.t. 1 ? b 0 ? c 0 and 0 ? j ? k} Primary Protocol MAPPP t : {[b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] s.t. ?0 ? i ? k [b i , c i ] ? 

 Label the Rule Rule construction produces unlabeled rules. To label these rules, we use a labeling protocol, defined as a function that takes a construction request as input, and returns a set of labels. Figure  7  defines a number of general-purpose la-Secondary Protocol TRIVSP A (x): return sreqs(x, A) Secondary Protocol MAPSP ?,A (x):  {[? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] ? sreqs(x, A) s.t. ?0 ? i ? k : [? i , ? i ] ? spans(? )} ; x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] is a subrequest. beling protocols. Some of these are driven by trees. We will represent a tree as a spanmap, defined as a function that maps spans to symbol sequences. For instance, if a parse tree has constituent NP over span  [4, 7] , then the corresponding spanmap t has t([4, 7]) = NP . We map spans to sequences in order to accommodate unary chains in the parse tree. Nonconstituent spans are mapped to the empty sequence. For spanmap t, let spans(t) be the set of spans [b, c] for which t([b, c]) is a nonempty sequence. 

 Extraction Programs In the previous section, we developed a general technique for extracting labeled rules from aligned sentence pairs. Note that this was not an algorithm, but rather an algorithmic schema, as it left two questions unanswered: 1. What construction requests do we make? 

 What labeling protocol do we use? We answer these questions with an extraction program, defined as a triple X , ?, L , where: ? X is a set of subrequests, referred to as the primary protocol. It specifies the set of primary subrequests that interest us. Figure  5  defines some general-purpose primary protocols. ? ? maps every subrequest to a set of subrequests. We refer to ? as the secondary protocol. It specifies the set of secondary subrequests that interest us, given a particular primary subrequest. Figure  6  defines some general-purpose secondary protocols. Labeling Protocol TRIVLP(x, ?): return ? k+1 Labeling Protocol PMAPLP t (x, ?): { l 0 , ..., l k s.t. ?0 ? i ? k : l i ? t([b i , c i ])} Labeling Protocol PMAPLP T (x, ?): t?T PMAPLP t (x, ?) Labeling Protocol SMAPLP ? (x, ?): { ? 0 , ..., ? k s.t. ?0 ? i ? k : ? i ? ? ([? i , ? i ])} Labeling Protocol SMAPLP T (x, ?): ? ?T SMAPLP ? (x, ?) Labeling Protocol IMAPLP T,T (x, ?): { (l 0 , ? 0 ), ..., (l k , ? k ) s.t. l 0 , ..., l k ? PMAPLP T (x, ?) and ? 0 , ..., ? k ? SMAPLP T (x, ?)} ? L is a labeling protocol. Figure  7  defines some general-purpose labeling protocols. Figure  8  shows the pseudocode for an "evaluator" that takes an extraction program (and an aligned sentence pair) as input and returns a set of labeled rules. 

 The GHKM Extraction Program As previously stated, we developed our extraction schema by generalizing the GHKM algorithm  (Galley et al., 2004) . To recover GHKM as an instance of this schema, use the following program: EXTRACT s,?,A (MAPPP t , TRIVSP A , PMAPLP t ) where t is a spanmap encoding a parse tree over the primary sentence. Algorithm EXTRACT s,?,A (X , ?, L): R = {} for all subrequests x ? X do for all subrequests ? ? ?(x) do s, ?, A is an aligned sentence pair; X is a primary protocol; ? is a secondary protocol; L is a labeling protocol. U = CONSTRUCTRULE s,?,A (x, ?) L = L(x, ?) R = R ? (U ? L) end for end for return R 

 The Phrase Pair Extraction Program In this section, we express phrase pair extraction  (Och et al., 1999)  as an extraction program. For primary span [b, c] and secondary span [?, ?] of alignment A, let [b, c] A ? [?, ?] if the following three conditions hold: 1. a A ? ? for some a ? [b, c] and ? ? [?, ?] 2. a A ? ? for all a ? [b, c] and ? ? [?, ?] 3. a A ? ? for all a ? [b, c] and ? ? [?, ?] Define the ruleset PBMT(s, ?, A) to be the set of labeled rules r, ? 1 such that: ? r = 0, "s b ...s c ", "? ? ...? ? ", ? ? [b, c] A ? [?, ?] We want to express PBMT(s, ?, A) as an extraction program. First we establish a useful lemma and corollary. Lemma 1. [b, c] A ? [?, ?] iff [b, c] ? frontier(A) and [?, ?] ? pproj A ([b, c]). Proof. Let [b, c] c = [1, b ? 1] ? [c + 1, |A| p ]. [b, c] ? frontier(A) and [?, ?] ? pproj A ([b, c]) (1) ? pmproj A ([b, c]) ? pimage A ([b, c] c ) = {} [?, ?] ? pproj A ([b, c]) (2) ? [?, ?] ? pimage A ([b, c] c ) = {} [?, ?] ? pproj A ([b, c]) (3) ? [?, ?] ? pimage A ([b, c] c ) = {} pimage A ([b, c]) ? [?, ?] (4) ? conditions 2 and 3 hold [?, ?] = {}  Corollary 2. Consider monotonic subrequest x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] and arbitary subrequest ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ]. Construction request x, ? matches alignment A iff [b i , c i ] A ? [? i , ? i ] for all 0 ? i ? k. We are now ready to express the rule set PBMT(s, ?, A) as an extraction program. 

 Theorem 3. PBMT(s, ?, A) = EXTRACT s,?,A (RANKPP 0 , TRIVSP A , TRIVLP) Proof. r, l ? EXT s,?,A (RANKPP 0 , TRIVSP A , TRIVLP) (1) ? ? ? ? ? ? ? ? ? ? ? ? x = [b, c] and ? = [?, ?] x, ? matches alignment A {r} = CONSTRUCTRULE s,?,A (x, ?) l = ? 1 (2) ? ? ? ? ? ? ? ? ? ? ? ? x = [b, c] and ? = [?, ?] x, ? matches alignment A r = 0, "s b ...s c ", "? ? ...? ? ", ? l = ? 1 (3) ? ? ? ? ? ? ? ? [b, c] A ? [?, ?] r = 0, "s b ...s c ", "? ? ...? ? ", ? l = ? 1 (4) ? r, l ? PBMT(s, ?, A) Equivalence 1 holds by the definition of EXTRACT and RANKPP 0 . Equivalence 2 holds by the pseudocode of CONSTRUCTRULE. Equivalence 3 holds from Corollary 2. Equivalence 4 holds from the definition of PBMT(s, ?, A). 

 The Hiero Extraction Program In this section, we express the hierarchical phrasebased extraction technique of  (Chiang, 2007)  as an extraction program. Define HIERO 0 (s, ?, A) = PBMT(s, ?, A). For positive integer k, define HIERO k (s, ?, A) as the smallest superset of HI-ERO k?1 (s, ?, A) satisfying the following condition: ? For any labeled rule k ? 1, s * , ? * , ? , ? k ? HIERO k?1 (s, ?, A) such that: 1. s * = s * 1 ? "s b ...s c " ? s * 2 2. ? * = ? * 1 ? "? ? ...? ? " ? ? * 2 3. ? = ? 1 , ? 2 , ..., ? k?1 4. s * 2 has rank 0. 4 5. ? * 1 has rank j. 6. [b, c] A ? [?, ?] it holds that labeled rule r, ? k+1 is a member of HIERO k (s, ?, A), where r is: k, s * 1 ? "?" ? s * 2 , ? * 1 ? "?" ? ? * 2 , ? 1 , ..., ? j , k, ? j+1 , ..., ? k?1 Theorem 4. HIERO k (s, ?, A) = EXTRACT s,?,A (RANKPP k , TRIVSP A , TRIVLP) Proof. By induction. Define ext(k) to mean EXTRACT s,?,A (RANKPP k , TRIVSP A , TRIVLP). From Theorem 3, HIERO 0 (s, ?, A) = ext(0). 

 Assume that HIERO k?1 (s, ?, A) = ext(k ? 1) and prove that HIERO k (s, ?, A)\HIERO k?1 (s, ?, A) = ext(k)\ext(k ? 1). r , l ? ext(k)\ext(k ? 1) (1) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] x , ? matches alignment A {r } = CONSTRUCTRULE s,?,A (x , ? ) l = ? k+1 4 This condition is not in the original definition. It is a cosmetic addition, to enforce the consecutive ordering of variable indices on the rule LHS. ( 2) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k?1 , c k?1 ] ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k?1 , ? k?1 ] {r} = CONSTRUCTRULE s,?,A (x, ?) ? = ? 1 , ..., ? k?1 r = k ? 1,s * 1 ? "s b k ...s c k " ? s * 2 , ? * 1 ? "? ? k ...? ? k " ? ? * 2 , ? s * 2 has rank 0 and ? * 1 has rank j x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] x , ? matches alignment A ? = ? 1 , ..., ? j , k, ? j+1 , ..., ? k?1 r = k, s * 1 ? "?" ? s * 2 , ? * 1 ? "?" ? ? * 2 , ? l = ? k+1 (3) ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? = ? 1 , ..., ? k?1 r = k ? 1,s * 1 ? "s b k ...s c k " ? s * 2 , ? * 1 ? "? ? k ...? ? k " ? ? * 2 , ? s * 2 has rank 0 and ? * 1 has rank j r, ? k ? HIERO k?1 (s, ?, A) ? = ? 1 , ..., ? j , k, ? j+1 , ..., ? k?1 r = k, s * 1 ? "?" ? s * 2 , ? * 1 ? "?" ? ? * 2 , ? [b i , c i ] A ? [? i , ? i ] for all 0 ? i ? k l = ? k+1 (4) ? r , l ? HIERO k (s, ?, A)\HIERO k?1 (s, ?, A) Equivalence 1 holds by the definition of ext(k)\ext(k ? 1). Equivalence 2 holds by the pseudocode of CONSTRUCTRULE. Equivalence 3 holds by the inductive hypothesis and Corollary 2. Equivalence 4 holds by the definition of HIERO k (s, ?, A)\HIERO k?1 (s, ?, A). 

 Discussion In this paper, we have created a framework that allows us to express a desired rule extraction method as a set of construction requests and a labeling protocol. This enables a modular, "mix-and-match" approach to rule extraction. In Table  1 , we summarize the results of this paper, as well as our conjectured extraction programs for several other methods. For instance, Syntax-Augmented Machine Translation (SAMT)  (Zollmann and Venugopal, 2006 ) is a hybridization of Hiero and GHKM that uses the primary protocol of Hiero and the labeling protocol of GHKM. To bridge the approaches, SAMT employs a fuzzy version 5 of the spanmap t that assigns a trivial label to non-constituent primary spans: t([b, c]) = t([b, c]) if [b, c] ? spans(t) ? otherwise Other approaches can be similarly expressed as straightforward variants of the extraction programs we have developed in this paper. Although we have focused on idealized methods, this framework also allows a compact and precise characterization of practical restrictions of these techniques. For instance,  (Chiang, 2007)  lists six criteria that he uses in practice to restrict the generation of Hiero rules. His condition 4 ("Rules can have at most two nonterminals.") and condition 5 ("It is prohibited for nonterminals to be adjacent on the French side.") can be jointly captured by replacing Hiero's primary protocol with the following: His other conditions can be similarly captured with appropriate changes to Hiero's primary and secondary protocols. This work is primarily intended as a survey of the dominant translation rule extraction paradigms, in which we make explicit the close relationship between these approaches, and establish a language for future hybridizations. From a practical perspective, we facilitate a generic and extensible implementation which supports a wide variety of existing methods, and which permits the precise expression of practical extraction heuristics.  5  This corresponds with the original formulation of Syntax Augmented Machine Translation  (Zollmann and Venugopal, 2006) . More recent versions of SAMT adopt a more refined "fuzzifier" that assigns hybrid labels to non-constituent primary spans. [b, c] of positive integers such that b ? c. We will treat span [b, c] as the implicit encoding of the set {b, b + 1, ..., c}, and employ set-theoretic operations on spans, e.g. [3, 8] ? [6, 11] = [6, 8]. Note that the null span encodes the empty set. If a set I of positive integers is non-empty, then it has a unique minimal enclosing span, defined by the operator span(I) = [min(I), max(I)]. For instance, span({1, 3, 4}) = [1, 4]. Define span({}) = ?. 

 Figure 1 : 1 Figure 1: A demonstration of alignment terminology. (a) An alignment is a relation between positive integer sets. (b) The primary domain of the example alignment is {1,2,3,4} and the secondary domain is {1,3,5}. (c) The image of primary span [2,4] is {3,5}. (d) The minimal projection of primary span [2,4] is [3,5]. Secondary spans [2,5], [3,6], and [2,6] are also projections of primary span [2,4]. 

 pdom(A) = {a|? s.t. a A ? ?}. Analogously, define sdom(A) = {?|?a s.t. a A ? ?}. For the example alignment of Figure 1(b), pdom(A) = {1, 2, 3, 4} and sdom(A) = {1, 3, 5}. Image: The image of a set I of primary indices (denoted pimage A (I)) is the set of secondary indices to which the primary indices of I align. In Figure 1(c), for instance, the image of primary span [2, 4] is the set {3, 5}. Formally, for a set I of primary indices of alignment A, define: pimage A (I) = {?|?a ? I s.t. (a, ?) ? A} Projection: The minimal projection of a set I of primary indices (denoted pmproj A (I)) is the minimal enclosing span of the image of I. In other words, pmproj A (I) = span(pimage A (I)). In Figure 1(d), for instance, the minimal projection of primary span [2, 4] is the secondary span [3, 5]. 

 Figure 2: An example SCFG label (top) and STSG label (bottom) for unlabeled rule ? le ? 1 ? 2 de ? 3 , ? 3 's ? 2 ? 1 . 

 Figure 3 : 3 Figure 3: Extraction of the unlabeled rule ? ? ? 1 does not ? 2 , ? 1 ne ? 2 pas . (a) Choose primary subrequest [1, 4] [1, 1][4, 4]. (b) Choose secondary subrequest [1, 4] [1, 1][3, 3]. (bottom) Construct the rule ? ? ? 1 does not ? 2 , ? 1 ne ? 2 pas . 

 Figure 4 : 4 Figure 4: Pseudocode for rule construction. Arguments: s= "s 1 s 2 ... s m " and ? = "? 1 ? 2 ... ? n " are sentences, A = m, n, A is an alignment, x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] and ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] are subrequests. 

 Figure 6 : 6 Figure 6: Various secondary protocols. Parameters: ? is a spanmap; A is an alignment; x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] is a subrequest. 

 Figure 7 : 7 Figure 7: Various labeling protocols. Parameters: t, ? are spanmaps; T, T are sets of spanmaps; x = [b 0 , c 0 ] [b 1 , c 1 ]...[b k , c k ] and ? = [? 0 , ? 0 ] [? 1 , ? 1 ]...[? k , ? k ] are subrequests. 

 Figure 8 : 8 Figure 8: Evaluator for extraction programs. Parameters:s, ?, A is an aligned sentence pair; X is a primary protocol; ? is a secondary protocol; L is a labeling protocol. 

 by definition of frontier(A). Equivalence 2 holds because [?, ?] differs from pmproj A ([b, c]) only in unaligned indices. Equivalence 3 holds because given the disjointness from pimage A ([b, c] c ), [?, ?] differs from pimage A ([b, c]) only in unaligned indices. Equivalences 4 and 5 are a restatement of conditions 2 and 3 plus the observation that empty spans can satisfy conditions 2 and 3. 

 { [b 0 , c 0 ] [b 1 , c 1 ]...[b j , c j ] s.t. 1 ? b 0 ? c 0 0 ? j ? 2 b 2 > c 1 + 1} 

 Table 1 : 1 Various rule extraction methods, expressed as extraction programs. Boldfaced methods are proven in this paper; the rest are left as conjecture. Parameters: t, ? are spanmaps (see Section 3); t, ? are fuzzy spanmaps (see Section 7); T, T are sets of spanmaps (typically encoded as forests); A is an alignment (see Section 2). 

			 Our definition of the frontier property is an equivalent reexpression of that given in (Galley et al., 2004) . We reexpress it in these terms in order to highlight the fact that the frontier
