title
Neural Arabic Text Diacritization: State of the Art Results and a Novel Approach for Machine Translation

abstract
In this work, we present several deep learning models for the automatic diacritization of Arabic text. Our models are built using two main approaches, viz. Feed-Forward Neural Network (FFNN) and Recurrent Neural Network (RNN), with several enhancements such as 100-hot encoding, embeddings, Conditional Random Field (CRF) and Block-Normalized Gradient (BNG). The models are tested on the only freely available benchmark dataset and the results show that our models are either better or on par with other models, which require language-dependent postprocessing steps, unlike ours. Moreover, we show that diacritics in Arabic can be used to enhance the models of NLP tasks such as Machine Translation (MT) by proposing the Translation over Diacritization (ToD) approach.

Introduction In Arabic and many other languages, diacritics are added to the characters of a word (as short vowels) in order to convey certain information about the meaning of the word as a whole and its place within the sentence. Arabic Text Diacritization (ATD) is an important problem with various applications such as text to speech (TTS). At the same time, this problem is a very challenging one even to native speakers of Arabic due to the many subtle issues in determining the correct diacritic for each character from the list shown in Figure  2  and the lack of practice for many native speakers. Thus, the need to build automatic Arabic text diacritizers is high  (Zitouni and Sarikaya, 2009) . The meaning of a sentence is greatly influenced by the diacritization which is determined by the context of the sentence as shown in the following example: Buckwalter Transliteration: klm >Hmd ... Incomplete sentence without diacritization. Buckwalter Transliteration: kal?ama >aHomadN Sadiyqahu Translation: Ahmad talked to his friend. Buckwalter Transliteration: kalama >aHomadN Eaduw?ahu Translation: Ahmad wounded his enemy. The letters "klm" manifests into two different words when given two different diacritizations. As shown in this example, "kal?ama" in the first sentence is the verb 'talked' in English, while "kalama" in the second sentence is the verb 'wounded' in English. To formulate the problem in a formal manner: Given a sequence of characters representing an Arabic sentence S, find the correct diacritic class (from Figure  2 ) for each Arabic character S i in S. Despite the problem's importance, it received limited attention. One of the reasons for this is the scarcity of freely available resources for this problem. To address this issue, the Tashkeela Corpus 1 (Zerrouki and Balla, 2017) has been released to the community. Unfortunately, there are many problems with the use of this corpus for benchmarking purposes. A very recent study  (Fadel et al., 2019)  discussed in details these issues and provided a cleaned version of the dataset with predefined split into training, testing and validation sets. In this work, we use this dataset and provide yet another extension of it with a larger training set and a new testing set to circumvent the issue that some of the existing systems have already be-en trained on the entire Tashkeela Corpus. According to  (Fadel et al., 2019) , existing approaches to ATD are split into two groups: traditional rule-based approaches and machine learning based approaches. The former was the main approach by many researchers such as  (Zitouni and Sarikaya, 2009; Pasha et al., 2014; Darwish et al., 2017)  while the latter has started to receive attention only recently  (Belinkov and Glass, 2015; Abandah et al., 2015; Barqawi and Zerrouki, 2017; Mubarak et al., 2019) . Based on the extensive experiments of  (Fadel et al., 2019) , deep learning approaches (aka neural approaches) are superior to non-neural approaches especially when large training data is available. In this work, we present several neural ATD models and compare their performance with the state of the art (SOTA) approaches to show that our models are either on par with the SOTA approaches or even better. Finally, we present a novel way to utilize diactritization in order to enhance the accuracy of Machine Translation (MT) models in what we call Translation over Diacritization (ToD) approach. The rest of the paper is organized as follows. The following section discusses the dataset proposed by  (Fadel et al., 2019) . Sections 3 and 4 discuss our two main approaches: Feed-Forward Neural Network (FFNN) and Recurrent Neural Network (RNN), respectively. Section 5 brielfy discusses the related work and presents a comparison with the SOTA approaches while Section 6 describes our novel approach to integrate diacritization into translation tasks. The paper is concluding in Section 7 with final remarks and future directions of this work. 

 Dataset The dataset of  (Fadel et al., 2019)  (which is an adaptation of the Tashkeela Corpus) consists of about 2.3M words spread over 55K lines. Basic statistics about this dataset size, content and diacritics usage are given in Table  1 . Among the resources provided with this dataset are new definitions of the Diacritic Error Rate (DER), which is "the percentage of misclassified Arabic characters regardless of whether the character has 0, 1 or 2 diacritics", and the Word Error Rate (WER), which is "the percentage of Arabic words which have at least one misclassified Arabic character".  2  The redefinition of these measures is to exclu-2 DER/WER are computed with diacritization stat.py 3 The Feed-Forward Neural Network (FFNN) Approach This is our first approach and we present three models based on it. In this approach, we consider diacritizing each character as an independent problem. To do so, the model takes a 100-dimensional vector as an input representing features for a single character in the sentence. The first 50 elements in the vector represent the 50 non-diacritic characters before the current character and the last 50 elements represent the 50 non-diacritic characters after it including the current character. For example, the sentence ' ', the vector related to the character ' ' is as shown in Figure 1. As the figure shows, there are two characters before the character ' ' and four after it (including the whitespace). The special token '<PAD>' is used as a filler when there are no characters to feed. Note that the dataset contains 73 unique characters (without the diacritics) which are mapped to unique integer values from 0 to 74 after sorting them based on their unicode representations including the special padding and unknown ('<UNK>') tokens. Each example belongs to one of the 15 classes under consideration, which are shown in Figure 2. The model outputs probabilities for each  Basic Model. The basic model consists of 17 hidden layers of different sizes. The activation function used in all layers is Rectified Linear Unit (Re-LU) and the number of trainable parameters is about 1.5M. For more details see Appendix A. The model is trained for 300 epochs on an Nvidia Ge-Force GTX 970M GPU for about 16 hours using AdaGrad optimization algorithm  (Duchi et al., 2011)  with 0.01 learning rate, 512 batch size, and categorical cross-entropy loss function. 100-Hot Model. In this model, each integer from the 100-integer inputs is converted into its 1-hot representation as a 75-dimensional vector. Then, the 100 vectors are concatenated forming a 7,500dimensional vector. Based on empirical exploration, the model is structured to have five hidden layers with dropout. It has close to 2M trainable parameters. For more details see Appendix A. The model is trained for 50 epochs on an Nvidia GeForce GTX 970M GPU for about 3 hours using Adam optimization algorithm (Kingma and Ba, 2014) with 0.001 learning rate, 0.9 beta1, 0.999 beta2, 512 batch size, and categorical crossentropy loss function. Embeddings Model. In this model, the 100-hot layer is replaced with an embeddings layer to learn feature vectors for each character through the training process. Empirically determined, the model has five hidden layers with only 728K trainable parameters. For more details see Appendix A. The model is trained with the same configurations as the 100-hot model and the training time is about 2.5 hours only. Results and Analysis. Although the idea of diacritizing each character independently is counterintuitive, the results of the FFNN models on the test set (shown in Table  2 ) are very promising with the embeddings model having an obvious advantage over the basic and 100-hot models and performing much better than the best rule-based diacritization system Mishkal 3 among the systems reviewed by  (Fadel et al., 2019)  (Mishakl DER: 13.78% vs FFNN Embeddings model DER: 4.06%). However, these models are still imperfect. More detailed error analysis of these models is available in Appendix A. 

 The Recurrent Neural Network (RNN) Approach Since RNN models usually need huge data to train on and learn high-level linguistic abstractions, we prepare an external training dataset following the guidelines of  (Fadel et al., 2019) . The extra training dataset is extracted from the Classical Arabic (CA) part of the Tashkeela Corpus and the Holy Quran (HQ). We exclude the lines that already exist in the previously mentioned dataset. Note that, with the extra training dataset the number of unique characters goes up to 87 (without the diacritics). Table  3  shows the statistics for the extra training dataset. The lines in the dataset are split using the following 14 punctuations ('.', ',', ' ', ':', ';', ' ' , '(', ')', '[', ']', '{', '}', ' ' and ' '). After that, the lines with length more than 500 characters (without counting diacritics) are split into lines of length no more than 500. This step is necessary for the training phase to limit memory usage within a single batch. Note that the splitting procedure is omitted within the prediction phase, e.g., when calculating DER/WER on the validation and test sets. Moreover, four special tokens ('<SOS>', '<EOS>', '<UNK>' and '<PAD>') are used to prepare the input data before feeding it to the model. '<SOS>' and '<EOS>' are added to the start and the end of the sequences, respectively. '<UNK>' is used to represent unknown characters not seen in the training dataset. Finally, '<PAD>' is appended to pad the sequences within the same batch.  The exploration is done to tune different hyperparameters and find the structure that gives the best DER, which, in most cases, leads to better WER. Because the neural network size have a great impact on performance, we primarily experiment with the number of Bidirectional CuD-NN Long Short-Term Memory (BiCuDNNLSTM)  (Appleyard et al., 2016)  layers and their hidden units. By using either one, two or three layers, the error significantly decreases going from one layer to two layers. However, it shows slight improvement (if any) when going from two layers to three layers while increasing the training time. So, we decide to use two BiCuDNNLSTMs in further experiments as well as 256 hidden units per layer as using less units will increase the error rate while using more units does not significantly improve it. Then, we experiment with the size and depth of the fully connected feed-forward network. The results show that the depth is not as important as the size of each layer. The best results are produced with the model using two layers with 512 hidden units each. All experiments are done using Adam optimization algorithm, because different optimizers like Stochastic Gradient Descent, Adagrad and Adadelta do not converge to the optimal minimal fast enough and RMSprop, Nadam and Adamax give the same or slightly worse results. The number of character features to learn in the embedding layer that gives the best results is 25, where more features leads to little improvement and more overfitting, and less features makes the training harder for the network. This is probably due to the input vocabulary being limited to 87 different characters. We also experiment with training the models for more than 50 epochs, but the return is very little or it makes the learning unstable and eventually causes exploding gradients leaving the network with useless predictions, unable to learn anymore. The best model is structured as shown in Figure  3 . The training is done twice: with and without the extra training dataset, in order to explore the impact of the dataset size on the training phase for the diacritization problem. This has led to reduced overfitting. A weights averaging technique over the last few epochs is applied to partially overcome the overfitting issue and obtain a better generalization. Models in all following experiments are trained on Google Colab 4  (Carneiro et al., 2018)  environment for 50 epochs using an Nvidia Tesla T4 GPU, Adam optimization algorithm with 0.001 learning rate, 0.9 beta1, 0.999 beta2, 10 ?7 epsilon, 256 batch size, and categorical cross-entropy loss function. Conditional Random Field (CRF) Model. A CRF classifier is used in this model instead of the Softmax layer to predict the network output. CRF is usually more powerful than Softmax in terms of sequence dependencies in the output layer which exist in the diacritization problem. It is worth mentioning that CRF is considered to be "a best practice" in sequence labeling problems. However, in this particular problem, the results show that CRF performs worse than Softmax in most cases except for WER results when training without the extra dataset which indicates that, even with worse DER results, CRF is able to make more consistent predictions within the same word. Block-Normalized Gradient (BNG) Model. In this model,  (Yu et al., 2017) 's BNG method is applied to normalize gradients within each batch. This can help accelerate the training process. According to  (Yu et al., 2017) , this method performs better in RNN when using optimizers with adaptive step sizes, such as Adam. It can also lead to solutions with better generalization. This coincides with our results. Discussion and Analysis. The results of the RNN models on the test set (shown in Table  4 ) are much better than the FFNN models by about 67%. To show the effect of the weights averaging technique, Table  5  reports the DER/WER statistics related to the BNG model after averaging its weights over the last 1, 5, 10, and 20 epochs. Studying the confusion matrices for all the models suggests that the Shadda class and the composite classes (i.e., Shadda + another diacritic) are harder to learn for the network compared to other classes. However, with the extra training dataset, the network is able to find significantly better results compared to the results without the extra training dataset, especially for the Shadda class. The comparison method for calculating DER/WER without case ending skips comparing the diacritization on the end of each word. This skip improves the best DER to 1.34% (vs 1.69%) and best WER to 2.91% (vs 5.09%) which is a 26% improvement in DER and 43% improvement in WER. This is because the diacritic of the last character of the word usually depends on the part of speech tag making it harder to diacritize. However, we note that the actual last character of the word may come before the end of the word if the word has some suffix added to it. ' means 'his book' where the last character ' ' is the suffix representing the pronoun 'his', and the letter before it may take three different diacritics depending on its part of speech tagging. More detailed error analysis of these models available in Appendix B. Furthermore, an Encoder-Decoder structure (seq2seq) was built using BiCuDNNLSTMs to encode a sequence of characters and generate a sequence of diacritics, but the model was not able to successfully learn the alignment between inputted characters and outputted diacritics. Other attempts tried encoding the sentences as sequences of words and generate a sequences of diacritics also terribly failed to learn. The BNG model performs the best compared to other models described above. So, it is used for comparison with other systems in the following section. 

 Comparison with Existing Systems As mentioned earlier, the efforts on building automatic ATD is limited. A recent study  (Fadel et al., 2019)  surveyed existing approaches and tools for ATD. After discussing the limitations in closedsource tools, they divided existing approaches to ATD into two groups: traditional rule-based approaches  (Zitouni and Sarikaya, 2009; Pasha et al., 2014; Shahrour et al., 2015; Alnefaie and Azmi, 2017; Bebah et al., 2014; Azmi and Almajed, 2015; Chennoufi and Mazroui, 2017; Darwish et al., 2017; Fashwan and Alansary, 2017; Alqahtani et al., 2019)  and machine learning based approaches  (Belinkov and Glass, 2015;      Barqawi and Zerrouki, 2017; Moumen et al., 2018; Mubarak et al., 2019) . The extensive experiments of  (Fadel et al., 2019)  showed that neural ATD models are superior to their competitors especially when large training data is available. Thus, we limit our attention in this work to such models. According to  (Fadel et al., 2019) , the Shakkala system  (Barqawi and Zerrouki, 2017)  performs the best compared to other existing systems using the test set and the evaluation metrics proposed in  (Fadel et al., 2019) . Considering our best model's results mentioned previously, it is clear that our model outperforms Shakkala on the testing set after splitting the lines to be at most 315 characters long (Shakkala system limit), which causes a slight drop in our best model's results. However, since Shakkala was also trained on Tashkeela Corpus, we develop an auxiliary test set extracted from three books from Al-Shamela Library 5 ' ', ' ' and ' ' using the 5 http://shamela.ws same extraction and cleaning method proposed by  (Fadel et al., 2019)  while keeping only lines with more than 80% "diacritics to Arabic characters" rate. The extracted lines are each split into lines of lengths no more than 315 characters (without counting diacritics) which is the input limit of the Shakkala system. This produces a test set consisting of 443K words. Table  6  shows the results comparison with Shakkala. A comparison with the pre-trained model of  (Belinkov and Glass, 2015)  is also done using the test set and the evaluation metrics of  (Fadel et al., 2019)  while splitting the lines into lines of lengths no more than 125 characters (without counting diacritics) since any input with length more than that causes an error in their system. The results show that  (Belinkov and Glass, 2015) 's model performs poorly. However, we note that  (Belinkov and Glass, 2015) 's system was trained and tested on the Arabic TreeBank (ATB) dataset which consists of text in Modern Standard Arabic (MSA). So, to make a fair comparison with  (Belinkov and Glass, 2015) 's system, an auxiliary dataset is built from the MSA part of the Tashkeela Corpus using the same extraction and cleaning method proposed by  (Fadel et al., 2019)  keeping only lines with more than 80% "diacritics to Arabic characters" rate. This test set consists of 111K words. The results are reported in Table  7 . In addition to the poor results of (Belinkov and Glass, 2015)'s system, its output has a large number of special characters inserted randomly. These characters are removed manually to make the evaluation of the system possible. Finally, we compare our model with  (Abandah et al., 2015) 's model which, to our best knowledge, is the most recent deep-learning work announcing the best results so far. To do so, we employ a similar comparison method to (Chennoufi and Mazroui, 2017)'s by using the 10 books from the Tashkeela Corpus and the HQ that were excluded from  (Abandah et al., 2015) 's test set. The sentences used for testing our best model are all sentences that are not included in the training dataset of  (Fadel et al., 2019)  or extra training dataset on which our model is trained. To make the comparison fair, we use the same evaluation metric as  (Abandah et al., 2015) , which is (Zitouni and Sarikaya, 2009)'s. Moreover, the characters with no diacritics in the original text are skipped similarly to  (Abandah et al., 2015) . The results are shown in Table  8 . It is worth mentioning that the results of  (Abandah et al., 2015)  include post-processing techniques, which improved DER by 23.8% as re-ported in  (Abandah et al., 2015) . It can be easily shown that, without this step, our model's results are actually superior. All codes related to the diacritization work are publicly available on GitHub, 6 and are also implemented into a web application 7 for testing purposes. 

 Translation over Diacritization (ToD) Word's diacritics can carry various types of information about the word itself, like its part of speech tag, the semantic meaning and the pronunciation. Intuitively, providing such extra features in NLP tasks has the potential to improve the results of any system. In this section, we show how we benefit from the integration of diacritics into Arabic-English (Ar-En) Neural Machine Translation (NMT) creating what we call Translation over Diacritization (ToD). Dataset Extraction and Preparation. Due to the lack of free standardized benchmark datasets for Ar-En MT, we create a mid-size dataset using the following corpora: GlobalVoices v2017q3, MultiUN v1, News-Commentary v11, Tatoeba v2, TED2013 v1.1, Ubuntu v14.10, Wikipedia v1.0  (Tiedemann, 2012)  downloaded from Table  8 : Comparing the BNG model with  (Abandah et al., 2015)      (Sennrich et al., 2015)  is applied separately on both English and original (undiacritized) Arabic sequences to segment the words into subwords. This step overcomes the Out Of Vocabulary (OOV) problem and reduces the vocabulary size. Then, diacritics are added to Arabic subwords to create the diacritized version. Table  9  shows the number of tokens before and after BPE step for English, Original Arabic and Diacritized Arabic as well as the Diacritics forms when removing the Arabic characters. Model Structure The model used in the experiments is a basic Encoder-Decoder sequence to sequence (seq2seq) model that consists of a BiCuD-NNLSTM layer for encoding and a CuDNNLSTM layer for decoding with 512 units each (256 per direction for the encoder) while applying additive attention  (Bahdanau et al., 2014)  on the outputs of the encoder. As for the embeddings layer, a single randomly initialized embeddings layer with vector size 64 is used to represent the subwords when training without diacritics. Another layer with the same configuration is used to represent subwords' diacritics, which is concatenated with the subwords embeddings when training with diacritics. The model structure shown in Figure  5 .  

 Results and Discussion To explore the effect of the Arabic diacritization on the NMT task, we experiment with training both with and without diacritics. The models are trained for 50 epochs using an Nvidia Titan Xp GPU, Adam optimization algorithm with 0.001 learning rate, 0.9 beta1, 0.999 beta2, 10 ?7 epsilon and 256 batch size. The structure for training the model with diacritics may vary. We experiment with two variations where the first one uses the diacritized version of the sequences, while the other one uses the original sequences and the diacritics sequences in parallel. When merging diacritics with their sequences, we get more variations of each word depending on its different forms of diacritization, therefore expanding the vocabulary size. On the other hand, when separating diacritics from their sequences, the vocab size stays the same, and diacritics are added separately as extra input. The results in Table  10  show that training the model with diacritization compared to without diacritization improves marginally by 0.31 BLEU score 10 when using the 'with diacritics (merged)' data and improves even more when using the 'with diacritics (separated)' data by 1.33 BLEU score. Moreover, the training time and model size increases by about 20.6% and 41.4%, respectively, for using the 'with diacritics (merged)' data, while they only increase by about 3.4% and 4.5%, respectively, for using the 'with diacritics (separated)' data. By observing Figure  6 , which reports the BLEU score on all three models every 5 epochs, it is clear that, although the 'with diacritics (merged)' model converges better at the start of the training, it starts diverging after 15 epochs, which might be due to the huge vocab size and the training data size. By analysing Figure  6 , we find that BLUE score converges faster when training with diacritics (merged) compared to the other two approaches. However, it starts diverging later on due to vocabulary sparsity. As for with diacritics (separated), the BLUE score has higher convergence compared to without diacritics while also maintaining stability compared to with diacritics (merged). This is because separating diacritics solves the vocabulary sparsity issue while also providing the information needed to disambiguate homonym words. We note that, concurrently to our work, another work on utilizing diacritization for MT has recently appeared.  (Alqahtani et al., 2019)  used diacritics with text in three downstream tasks, namely Semantic Text Similarity (STS), NMT and Part of Speech (POS) tagging, to boost the performance of their systems. They applied different techniques to disambiguate homonym words through diacritization. They achieved 27.1 and 27.3 BLUE scores without and with diacritics, respectively, using their best disambiguation technique. This is a very small improvement of 0.74% compared to our noticeable improvement of 4.03%. Moreover, our approach is simpler and it does not require to drop any diacritical information. All codes related to the ToD work are publicly available on GitHub 11 . 10 BLEU scores are computed with multi-bleu.perl 11 https://github.com/AliOsm/ translation-over-diacritization   

 Conclusion In this work, we explored the ATD problem. Our models, which follow two main approaches: FF-NN and RNN, proved to be very effective as they performed on par with or better than SOTA approaches. In the future, we plan on investigating the sequence to sequence models such as RNN Seq2seq, Conv Seq2seq and Transformer. In another contribution of this work, we showed that diacritics can be integrated into other systems to attain enhanced versions in NLP tasks. We used MT as a case study and showed how our idea of ToD improved the results of the SOTA NMT system.  Figure 1 : 1 Figure 1: Vector representation of a FFNN example. 
