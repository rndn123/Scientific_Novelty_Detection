title
Anchor Graph: Global Reordering Contexts for Statistical Machine Translation

abstract
Reordering poses one of the greatest challenges in Statistical Machine Translation research as the key contextual information may well be beyond the confine of translation units. We present the "Anchor Graph" (AG) model where we use a graph structure to model global contextual information that is crucial for reordering. The key ingredient of our AG model is the edges that capture the relationship between the reordering around a set of selected translation units, which we refer to as anchors. As the edges link anchors that may span multiple translation units at decoding time, our AG model effectively encodes global contextual information that is previously absent. We integrate our proposed model into a state-of-the-art translation system and demonstrate the efficacy of our proposal in a largescale Chinese-to-English translation task. * This work was done when the authors were with IBM. 1  We define translation units as phrases in phrase-based SMT or as translation rules in syntax-based SMT.

Introduction Reordering remains one of the greatest challenges in Statistical Machine Translation (SMT) research as the key contextual information may span across multiple translation units.  1  Unfortunately, previous approaches fall short in capturing such cross-unit contextual information that could be critical in reordering. For example, state-of-the-art translation models, such as Hiero  (Chiang, 2005)  or Moses  (Koehn et al., 2007) , are good at capturing local reordering within the confine of a translation unit, but their formulation is approximately a simple unigram model over derivation (a sequence of the application of translation units) with some aid from target language models. Moving to a higher order formulation (say to a bigram model) is highly impractical for several reasons: 1) it has to deal with a severe sparsity issue as the size of the unigram model is already huge; and 2) it has to deal with a spurious ambiguity issue which allows multiple derivations of a sentence pair to have radically different model scores. In this paper, we develop "Anchor Graph" (AG) where we use a graph structure to capture global contexts that are crucial for translation. To circumvent the sparsity issue, we design our model to rely only on contexts from a set of selected translation units, particularly those that appear frequently with important reordering patterns. We refer to the units in this special set as anchors where they act as vertices in the graph. To address the spurious ambiguity issue, we insist on computing the model score for every anchors in the derivation, including those that appear inside larger translation units, as such our AG model gives the same score to the derivations that share the same reordering pattern. In AG model, the actual reordering is modeled by the edges, or more specifically, by the edges' labels where different reordering around the anchors would correspond to a different label. As detailed later, we consider two distinct set of labels, namely dominance and precedence, reflecting the two dominant views about reordering in literature, i.e. the first one that views reordering as a linear operation over a sequence and the second one that views reordering as a recursive operation over nodes in a tree structure The former is prevalent in phrase-based context, while the latter in hierarchical phrase-based and syntax-based context. More concretely, the dominance looks at the anchors' relative positions in the translated sentence, while the precedence looks at the anchors' relative positions in a latent structure, induced via a novel synchronous grammar: Anchorcentric, Lexicalized Synchronous Grammar. From these two sets of labels, we develop two probabilistic models, namely the dominance and the orientation models. As the edges of AG link pairs of anchors that may appear in multiple translation units, our AG models are able to capture high order contextual information that is previously absent. Furthermore, the parameters of these models are estimated in an unsupervised manner without linguistic supervision. More importantly, our experimental results demonstrate the efficacy of our proposed AGbased models, which we integrate into a state-of-theart syntax-based translation system, in a large scale Chinese-to-English translation task. We would like to emphasize that although we use a syntax-based translation system in our experiments, in principle, our approach is applicable to other translation models as it is agnostic to the translation units. 

 Anchor Graph Model Formally, an AG consists of {A, L} where A is a set of vertices that correspond to anchors, while L is a set of labeled edges that link a pair of anchors. In principle, our AG model is part of a translation model that focuses on the reordering within the source sentence F and its translation E. Thus, we start by first introducing A into a translation model (either word-based, phrase-based or syntax-based model) followed by L. Given an F , A is essentially a subset of non-overlapping (word or phrase) units that make up F . As the information related to A is not observed, we introduce A as a latent variable. Let P (E, ? |F ) be a translation model where ? corresponds to the alignments between units in F and E.  2  We introduce A into a translation model, 2 Alignment (?) represents an existing latent variable. Depending on the translation units, it can be defined at different level, i.e. word, phrase or hierarchical phrase. As during translation, we are interested in the anchors that appear inside larger translation units, we set ? at word level, which information can be induced for (hierarchical) phrase units by either keeping the word alignment from the training data inside the units or inferring it via lexical translation probability. We use the former. as follow: P (E, ? |F ) = ?A P (E, ?, A |F ) (1) P (E, ?, A |F ) = P (E, ? |A , F )P (A ) (2) As there can be many possible subsets of F and summing over all possible A is intractable, we make the following approximation for P (A ) such that we only need to consider one particular A * : P (A ) = ?(A = A * ) which returns 1 only for A * , otherwise 0. The exact definition of the heuristic will be described in Section 7, but in short, we equate A * with units that appear frequently with important reordering patterns in training data. Given an A * , we then introduce the edges of AG (L) into the equation as follow: P (E, ? |A * , F ) = P (E, ?, L|A * , F ) (3) Note that L is also a latent variable but its values are derived deterministically from (F, E, ?) and A * , thus no extra summation is present in Eq. 3. Then, we further simplify Eq. 3 by factorizing it with respect to each individual edges, as follow: P (E, ?, L|A * , F ) ? ?am,an?A * m<n P (L m,n |a m , a n ) (4) where L m,n ? L corresponds to the label of an edge that links a m and a n . In principle, L m,n can take any arbitrary value. For addressing the reordering challenge, it should ideally correspond to some aspect of the reordering around a m and a n , for example, how the reordering around a m affects the reordering around a n . As mentioned earlier, we choose to associate L m,n with the dominance and the precedence relations between a m and a n , where the former looks at the relative positions of the two anchors when they are projected into a latent tree structure, while the latter looks at their relative positions when they are projected into the target sentence. We illustrate the two in Fig.  1 . Furthermore, we assume that dominance and precedence are independent and develop one model for each, resulting in the dominance and the orientation models, which we describe in Section 3 and 4 respectively. To make the model more compact, we introduce an additional parameter O that restricts the maximum order of AG as follows: ? O o=1 |A * |+o?1 i=0 P o (L i?o,i |a i?o , a i ) (5) Thus, we only consider edges that link two anchors that are at most O ? 1 anchors apart. For O = 1, the AG model only considers relations between neighboring anchors. Following the standard practice in the n-gram language modeling, we append O number of pseudo anchors at the beginning and at the end of F , which represent the sentence delimiter markers. We do so in a monotone order.  

 Dominance Model This section describes our dominance model where we equate L m,n in Eq. 4 with dom(a m , a n ) that expresses to the dominance relation between a m and a n in a latent tree structure. Due to reordering, anchors can only appear in specific nodes. We first describe a novel formalism of Anchor-centric, Lexicalized Synchronous Grammar (AL-SG), used to induce the tree structure and then discuss the probabilistic formulation of the model. Just to be clear, we introduce AL-SG mainly to facilitate the computation of dom(a m , a n ). The actual translation model at decoding time remains either phrase-based, hierarchical phrase-based or syntax-based model. 

 Anchor-centric, Lexicalized Synchronous Grammar Given (F, E, ?) and A, Anchor-centric, Lexicalized Synchronous Grammar (AL-SG) produces a tree structure where the nodes are decorated with anchors-related information. As the name alludes, the core of AL-SG is anchor-centric constituents (ACC), which corresponds to nodes, composed from merging anchors with by either their left, their right neighboring constituents or both. More concretely, first of all, we consider a span on the source sentence F to be a constituent if it is consistent with the alignment (?). Second of all, we can construct a larger constituent by merging smaller constituents given that the larger constituent is also consistent with the alignment. These two constraints are similar to the heuristic applied to extract hierarchical phrases  (Chiang, 2005) . Then, specific to AL-SG, we consider an anchor a to lexicalize a constituent c, if: a) we can compose c from at most three smaller constituents: c L , a and c R where a is the anchor while c L ,c R are the (possibly empty) constituents immediately to the left and to the right of a; and b) we can create smaller anchorscentric constituents from concatenating a with c L and a with c R . If a can lexicalize c, then the node associated with c would be marked with a. In computing dom(a m , a n ), we look at the constituents that cover both anchors and check whether the anchors can lexicalized any of such constituents. Now, we will describe AL-SG in a formal way. For simplicity, we use a simple grammar, called Inversion Transduction Grammar (ITG)  (Wu, 1997) , although in practice, we handle a more powerful synchronous grammar. Hence, we proceed to describe Anchor-centric, Lexicalized ITG (AL-ITG). An AL-ITG is a quadruple {?, A, V, R} where: ? ? = {(f /e) } is a set of terminal symbols, which represents all possible units defined over (F, E, ?) where each pair corresponds to a link in ?. We define ? at the most fine-grained level (i.e. word-level), as we insist on computing model score for each anchors even if they appear inside larger units. ? A ? ? is a set of anchors, which is a subset of the terminal symbols. ? V = {{P, X, Y } ? {A, ?}} is a set of (possibly lexicalized) nonterminal symbols. P represents the terminal symbols (?); while X and Y correspond to the spans that are created from merging two adjacent constituents. On the tar- get side, for X, the order of the two children follows the source order, while for Y , the order follows the inverse. Nonterminal symbols can be lexicalized with zero or more than one anchor. We represent a lexicalized constituent as a nonterminal symbol followed by a bracket which contains the lexicalizing anchors, e.g. P (H) where H is the anchors lexicalizing P . ? R is a set of production rules which can be classified into the following categories: -Preterminal rules. We propagate the symbol if it corresponds to an anchor. P (H = f /e) ? f /e, if f /e ? A * P (H = ?) ? f /e, otherwise -Monotone production rules, which reorder the children in monotone order, denoted by square brackets ("[","]"). X(H 1 ? H 2 ) ? [P (H 1 )P (H 2 )] X(H 1 ? H 2 ) ? [X(H 1 )P (H 2 )] X(H 1 ? H 2 ) ? [X(H 1 )X(H 2 )] X(H 1 ) ? [X(H 1 )Y (H 2 )] X(H 2 ) ? [Y (H 1 )P (H 2 )] X(H 2 ) ? [Y (H 1 )X(H 2 )] X(?) ? [Y (H 1 )Y (H 2 )] -Inverse production rules, which reorder the children in the inverse order, denoted by angle brackets (" "," "). Y (H 1 ? H 2 ) ? P (H 1 )P (H 2 ) Y (H 1 ? H 2 ) ? Y (H 1 )P (H 2 ) Y (H 1 ? H 2 ) ? Y (H 1 )Y (H 2 ) Y (H 1 ) ? Y (H 1 )X(H 2 ) Y (H 2 ) ? X(H 1 )P (H 2 ) Y (H 2 ) ? X(H 1 )Y (H 2 ) Y (?) ? X(H 1 )X(H 2 ) Like ITG, AL-ITG only permits two kind of reordering operations, namely monotone and inverse. To accommodate the lexicalization, we first assign a unique nonterminal symbol for each, i.e. X for monotone reordering and Y for inverse reordering. Then, we lexicalize Xs and Y s with anchors as long as they satisfy the constraint that the child shares the same label as the parent. This constraint guarantees that the constituents are valid ACCs. It also enables the anchors to lexicalize long constituents, although the terminal symbols are defined at word-level. Fig.  2  illustrates an example Chinese-to-English translation with a AL-ITG derivation when the grammar is applied in a left-to-right fashion. Admittedly, AL-ITG (or more generally AL-SG) is susceptible to spurious ambiguity as it produces multiple derivation trees for a given (F, E, ?). Fortunately, the value of dom(a m , a n ) is identical for all derivations, since the computation of dom(a m , a n ) relies only on whether a m and a n can lexicalize at least one constituent that covers both anchors. Hence, we only need to look at one derivation to compute dom(a m , a n ). Generalizing AL-ITG to a more powerful formalism is trivial; we just need to forbid the propagation for non-binarizeable production rules. 

 Probabilistic Model We read-off the dominance relations dom(a m , a n ) from D obtained from the application of AL-SG to (F, E, ?). As lexicalization is a bottom-up process, for reading-off dom(a m , a n ), it is sufficient to look at the lowest common ancestor (LCA) of both anchors; if the anchors cannot lexicalize the LCA, they won't be able to lexicalize the constituents larger than LCA. To be more concrete, let's consider the D in Fig.  2 . In that D, the LCA of a m = yu 3 /with 10 and a n = de 7 /that 7 is Y 5 (7). Then, we check the anchors that can lexicalize the LCA. Let V (H) be the LCA, then dom(a m , a n ) ? (LH) , if a m ? H ? a n ? H (RH) , if a m ? H ? a n ? H (BL) , if a m ? H ? a n ? H (BD) , if a m ? H ? a n ? H The value refers to cases where a m and a n can lexicalize V (H) and it is useful to model spans that share a simple, uniform reordering, i.e. allmonotone or all-inverse, while the value refers to the cases where a m and a n cannot lexicalize V (H) and it is useful to model spans that involve in a complex reordering. Meanwhile, the and refer to cases where only one anchor can lexicalize V (H), i.e. a m and a n respectively. These values are useful for modeling cases where the surroundings of the two anchors exhibit different kind of reordering pattern. With such definition, the edge labels L in Fig.  2  are indicated in Table  1 . Note that in Table  1 , we don't specify the relations involving pseudo anchors, although they are crucial. The final probabilistic formulation of the dominance model is as follows: ? O o=1 |A|+o?1 i=0 P domo (dom(a i?o , a i )|a i?o , a i ) (6) As shown, we allocate a separate model P domo for each separate order (o) where each P domo will con- H H H H H n m 1 2 3 4 5 1 = (shi 2 /is 2 ) - - - - - 2 = (yu 3 /with 10 ) LH - - - - 3 = (you 5 /have 8 ) LH BD - - - 4 = (de 7 /that 7 ) LH RH RH - - 5 = (zhi 10 /of 4 ) LH RH RH BL - Table 1: The dominance relations between pairs of anchors according to the derivation in Fig.  2 . tribute as one additional feature in the log-linear model of the translation model. In allocating a separate model for each o, we conjecture that different pair of anchors contributes differently depending on how far the two anchors are. 

 Orientation Model In this section, we introduce the orientation model (ori) where we equate L m,n with the precedence relations between a pair of anchors. Instead of directly modeling the precedence between the two anchors, we approximate it by modeling the precedence of each anchor with its neighboring constituents. Formally, we approximate P (L m,n |a m , a n ) as P ori R (ori(a m , M R (a m ))|a m ) ? P ori L (ori(a n , M L (a n ))|a n ) (7) where M R (a m ) is the largest constituent to the right of the first anchor a m , M L (a n ) the largest constituent to the left of the second anchor a n , and ori() a function that maps the anchor and the neighboring constituent to a particular orientation. Plugging Eq. 7 into Eq. 5 results in the following approximation of P (?|A): C. |A|?1 i=0 {P ori L (ori(a i , M L (a i ))|a i )? P ori R (ori(a i , M R (a i ))|a i )} O (8) where C is a constant term related to the pseudo anchors and O is the maximum order of the AG. In practice, we can safely ignore both C and O as they are constant for a given AG. As shown, the orientation model is simplified into a model that looks at the reordering of the anchors' neighboring constituents. The exact definition of M L and M R will be discussed in Section 5. Their orientation, i.e. ori L (C L , a) and ori R (C R , a) respectively, may take one of the following four values: (MA), (RA), (MG) and (RG). The first clause (monotone, reverse) indicates whether the target order follows the source order; the second (adjacent, gap) indicates whether the anchor and its neighboring constituent are adjacent or separated by an intervening when projected. 

 Parameter Estimation For each (F, E, ?), the training starts with the identification of the regions in the source sentences as anchors (A). For our Chinese-English experiments, we use a simple heuristic that equates anchors (A * ) with constituents whose corresponding word class belongs to function words-related classes, bearing a close resemblance to  (Setiawan et al., 2007) . In total, we consider 21 part-of-speech tags; some of which are as follows: VC (copula), DEG, DEG, DER, DEV (de-related), PU (punctuation), AD (adjectives) and P (prepositions). 

 Extracting Events from (F, E, ?) The parameter estimation first involves extracting two statistics from (F, E, ?), namely dom(a m , a n ) for the dominance model as well as ori(a, M L (a)) and ori(a, M R (a)) for the orientation model. Instead of developing a separate algorithm for each, we describe a unified way to extract these statistics via the largest neighboring constituents of the anchors, i.e. M L (a) and M R (a). This approach enables the dominance model to share the same residual state information as the orientation model.  3  Let a m be an anchor and M R (a m ) be its largest neighboring constituent to the right. Let a n be an anchor to the left of a m and M L (a n ) be a n 's largest neighboring constituent to the left. According to AL-SG, we say that a m dominates a n if ori(a m , M R (a m )) ? {M A, RA} and a n ? M R (a m ). By the same token, we say that a n dominates a m if ori(a n , M L (a n )) ? {M A, RA} and a m ? M L (a n ). The constraints on the orientation reflect the fact that in AL-SG, anchors can only be propagated through monotone or inverse production rules, which correspond to the M A and RA respectively. The fact that we are looking at the largest neighboring constituents guarantees that if the other anchor is outside that constituent, then that other anchor is never dominated. More formally, given an aligned sentence pair ? = (F, E, ?), let ?(?) be all possible constituents that can be extracted from ?: 4 {(f j 2 j 1 /e i 2 i 1 ) : ?(j, i) ?: ((j 1 ? j? j 2 ) ? (i i ? i? i 2 )) ?(?(j 1 ? j? j 2 ) ? ?(i i ? i? i 2 )) Then, let the anchors A be a subset of ?(?). Given A ? ?(?), let a = (f j 2 j 1 /e i 2 i 1 ) ? A be a particular anchor. And, let C L (a) ? ?(?) be a's left neighbors and let C R (a) ? ?(?) be a's right neighbors, iff: ?C L = (f j 4 j 3 /e i 4 i 3 ) ? C L (a) : j 4 + 1 = j 1 ?C R = (f j 6 j 5 /e i 6 i 5 ) ? C R (a) : j 2 + 1 = j 5 Then, let M L (a) ? C L (a) and M R (a) ? C R (a) be the largest left and right neighbors according to: M L (a) = arg max (f j 4 j 3 /e i 4 i 3 )?C L (a) (j 4 ? j 3 ) M R (a) = arg max (f j 6 j 5 /e i 6 i 5 )?C R (a) (j 6 ? j 5 ) Let M L = (f j 4 j 3 /e i 4 i 3 ) and M R = (f j 6 j 5 /e i 6 i 5 ). We then proceed to extract ori L (a, M L (a)) and ori R (a, M R (a)) respectively as follows: ? MA, if (i 4 + 1) = i 1 for ori L or if (i 2 + 1) = i 5 for ori R ? RA, if (i 2 + 1) = i 3 for ori L or if (i 6 + 1) = i 1 for ori R ? MG, if (i 4 + 1) < i 1 for ori L or if (i 2 + 1) < i 5 for ori R ? RG, if (i 2 + 1) < i 3 for ori L or if (i 6 + 1) < i 1 for ori R . Then, we proceed to extract dom(a m , a n ). Given two anchors a m , a n where m < n, we define the dominance relation between a m and a n via M R (a m ) and M L (a n ). Let a m = (f j 2 j 1 /e i 2 i 1 ), M R (a m ) = (f j 4 j 3 /e i 4 i 3 ), a n = (f j 6 j 5 /e i 6 i 5 ) and M L (a n ) = (f j 8 j 7 /e i 8 i 7 ). Then, ldom(a m , a n ) is true only if (j 4 ? j 6 ) and ori R (a m , M R (a m )) ? {M A, RA}. Similarly, rdom(a m , a n ) is true only if (j 7 ? j 1 ) and ori L (a n , M L (a n )) ? {M A, RA}. Hence, dom(a m , a n ) is as follows: ? LH, if ldom(a m , a n ) ? ?rdom(a m , a n ) ? RH, if ?ldom(a m , a n ) ? rdom(a m , a n ) ? BL, if ldom(a m , a n ) ? rdom(a m , a n ) ? BD, if ?ldom(a m , a n ) ? ?rdom(a m , a n ) 

 Parameterization and Training After extracting events, we are now ready to train the models. To estimate them, we train a discriminative classifier for each model and use the normalized posteriors at decoding time as additional feature scores in SMT's log-linear framework. At a high level, we use a rich set of binary features ranging from lexical to part-of-speech (POS) and to syntactic features. Additionally, we augment the feature set with compound features, e.g. a conjunction of the source word of the left anchor and the source word of the right anchor. Although they increase the number of features significantly, we found that they are empirically beneficial. Suppose a = (f j 2 j 1 /e i 2 i 1 ), M L (a) = (f j 4 j 3 /e i 4 i 3 ) and M R (a) = (f j 6 j 5 /e i 6 i 5 ), then based on the context's location, the elementary features employed in our classifiers can be categorized into: ? anchor-related: (the actual word of f j 2 j 1 ), (part-of-speech (POS) tag of ), ('s parent in the parse tree), (e i 2 i 1 's actual target word). ? surrounding: (the previous word / f j 1 ?1 j 1 ?1 ), (the next word / f j 2 +1 j 2 +1 ), ('s POS tag), ('s POS tag), ('s parent), ('s parent). ? non-local: (the previous anchor's source word) , (the next anchor's source word), ('s POS tag), ('s POS tag). There is a separate set of elementary features for a m and a n and we come up with manual combination to construct compound features. In training the models, we manually come up with around 30-50 types of features, which consists of a combination of elementary and compound features. Due to space constraints, we will describe the actual features that we use and the classification performance of our models elsewhere. In total, we generate around one hundred millions binary features from our training data that contains six million sentence pairs. To reduce the number of features, we employ the L1-regularization in training to enforce sparse solutions, using the off-the-shelf LIB-LINEAR toolkit  (Fan et al., 2008) . After training, the number of features in our classifiers decreases to below 1 million features for each classifier. 

 Decoding As mentioned earlier, we wish to avoid the spurious ambiguity issue where different derivations have radically different scores although they lead to the same reordering. This section describes our decoding algorithm that avoids spurious ambiguity issue by incrementally constructing M L s and M R s thus allowing the computation of the models over partial hypotheses. In our experiments, we integrate our dominance model as well as our orientation model into a syntaxbased SMT system that uses SCFG formalism. Integrating the models into syntax-based SMT systems is non-trivial, especially since the anchors often reside within translation rules and the model doesn't always decompose naturally with the hypothesis structure. To facilitate that, we need to first induce the necessary alignment for all translation units in the hypothesis. To describe the algorithm, let us consider a cheating exercise where we have to translate the Chinese sentence in Fig.  2  with the following set of hierarchical phrases: X a ? Aozhou 1 shi 2 X 1 , Australia 1 is 2 X 1 X b ? yu 3 Beihan 4 X 1 , X 1 with 3 North 4 Korea X c ? you 5 bangjiao 6 , have 5 dipl. 6 rels. X d ? X 1 de 7 shaoshu 8 guojia 9 zhi 10 yi 11 , one 11 of 10 the few 8 countries 9 that 7 X 1 As a case in point, let us consider D = X a ? X b ? X d ? X c , which will lead to the correct English Target string (w/ source index) Symbol(s) read Op. Stack(s) (1) X c have 5 dipl. 6 rels. [5][6] S,S,R X c :[5-6] (2) X d one 11 of 10 few 8 countries 9 [11][10] S,S,R [10-11] that 7 X c (3) [8][9] S,S,R,R [8-11] (4) [7] S [8-11][7] (5) X c :[5,6] S X d :[8-11][7][5,6] (6) X b X d with 3 North 4 Korea X d :[8-11][7][5,6] S [8-11][7][5,6] (7) [3][4] S,S,R,R X b :[8-11][7][3-6] (8) X a Australia 1 is 2 X b [1][2] S,S,R [1-2] (9) X b :[8-11][7][3,6] S,A X a :[1-2][8-11][7][3,6] Table  2 : The application of the shift-reduce parsing algorithm, which corresponds to the following derivation D = X a ? X b ? X d ? X c . Anchor is in bold. In column Op., S, R and A refer to shift, reduce and accept operation respectively. translation as in Fig.  2 . Note that the translation rules contain internal word alignment, which we assume to have been previously inferred. The algorithm bears a close resemblance to the shift-reduce algorithm found in phrase-based decoding  (Galley and Manning, 2008; Feng et al., 2010; Cherry et al., 2012) . A stack is used to accumulate (partial) information about a, M L and M R for each a ? A in the derivation. This algorithm takes an input stream and applies either the shift or the reduce operations starting from the beginning until the end of the stream. The shift operation advances the input stream by one symbol and push the symbol into the stack; while the reduce operation applies some rule to the top-most elements of the stack. The algorithm terminates at the end of the input stream where the resulting stack will be propagated to the parent for the later stage of decoding. In our case, the input stream is the target string of the rule and the symbol is the corresponding source index of the elements of the target string. The reduction rule looks at two indices and merge them if they are adjacent (i.e. has no intervening phrase). We forbid the application of the reduction rule to anchors. Table  2  shows the execution trace of the algorithm for the derivation described earlier. For conciseness, we assume that there is only one anchor and that is de 7 /that 7 . As shown, the algorithm starts with an empty stack. It then projects the source index to the corresponding target word and then enumerates the target string in a left to right fashion. If it finds a target word with a source index, it applies the shift oper-ation, pushing the index to the stack. Unless the symbol corresponds to an anchor, it tries to apply the reduce operation. Line (4) indicates the special treatment to the anchor. If the symbol being read is a nonterminal, then we push the entire stack that corresponds to that nonterminal. For example, when the algorithm reads X d at line (6), it pushes the entire stack from line (5). As M L s and M R s are being incrementally constructed, we can immediately compute P domo (dom(a m , a n )|a m , a n ) as soon as a partial derivation covers both a m and a n . For example, we can compute P dom 1 (dom(you 5 /have 8 , de 7 /that 7 ) = ), P dom 1 (dom(de 7 /that 7 , zhi 10 /of 4 ) = ) and P dom 2 (dom(you 5 /have 8 , zhi 10 /of 4 ) = ) at partial hypothesis X d ? X c which corresponds to a constituent spanning from 5-11. 

 Experiments Our baseline systems is a state-of-the-art string-todependency system  (Shen et al., 2008) . The system is trained on 10 million parallel sentences that are available to the Phase 1 of the DARPA BOLT Chinese-English MT task. The training corpora include a mixed genre of newswire, weblog, broadcast news, broadcast conversation, discussion forums and comes from various sources such as LDC, HK Law, HK Hansard and UN data. In total, our baseline model employs more than 50 features, including from our proposed dominance and orientation models. In addition to the standard  features such as translation probabilities, we incorporate features that are found useful for developing a state-of-the-art baseline, such as the provenance features . We use a 6-gram language model, which was trained on 10 billion English words from multiple corpora, including the English side of our parallel corpus plus other corpora such as Gigaword (LDC2011T07) and Google News. We also train a class-based language model  (Chen, 2009)  on two million English sentences selected from the parallel corpus. As for our string-todependency system, we train 3-gram models for left and right dependencies and unigram for head using the target side of the parallel corpus. To train our models, we select a set of 5 million sentence pairs. For the tuning and development sets, we set aside 1275 and 1239 sentences selected from LDC2010E30 corpus. We tune the feature weights with PRO  (Hopkins and May, 2011)  to minimize (TER-BLEU)/2 metric. As for the blind test set, we report the performance on the NIST MT08 evaluation set, which consists of 691 sentences from newswire and 666 sentences from weblog. We pick the weights that produce the highest development set scores to decode the test set. We perform two sets of experiments. The first set looks at the contribution of the dominance model with varying values of o. The second one looks at the combination of the dominance model and the orientation model. Table  3  summarizes the experimental results on NIST MT08 sets, categorized by genres. We report the results on newswire genre in columns a-c, those on weblog genre in column d-f, and those on mixed genre in column g-i. The performance of our baseline string-to-dependency syntaxbased SMT is shown in the first line. Lines 2-7 in Table  3  show the results of our first set of experiments, starting from the result of dom 1 , which looks at only at pairs of adjacent anchors, to the result of dom 6 , which looks at pairs of anchors that are at most 5 anchors away. As shown in line 2, our dominance model provides a nice improvement of around 0.5 point over the baseline even if it only looks at restricted context. Increasing the order of our dominance model provides an additional gain. However, the gain is more pronounced in the weblog genre (up to around 1 BLEU point) than in the newswire genre. We conjecture that this may be the artifact of our tune set, which comes from the weblog genre. We stop at dom 6 because we observe that the weight of the feature score that corresponds to the maximum order (o = 6) has a negative sign, which often indicates a high correlation between the new features and existing ones. Lines 8-13 in Table  3  shows the results of our second set of experiments. Line 8 shows the result of adding the orientation model (ori) to the baseline system. As shown, integrating ori shows a significant gain. On top of which, we then integrate dom 1 to dom 5 . We see a very encouraging result as adding the dominance model increases the performance further, consistently over different value of o. This suggests that the dominance model is complementary to the orientation model. Our best result provides more than 1 BP improvement and 1 TER reduction consistently over different genres. We see this result as confirming our intuition that the global contextual information provided by our AG model can significantly improve the performance of SMT even in a state-of-the-art system. 

 Related Work Our work intersects with existing work in many different respects. In this section, we mainly focus on work related to introducing higher-order contextual information to reordering model. In providing global contextual information, our work is related to a large amount of literature. To name a few,  Zens and Ney (2006)  improves the lexicalized reordering model of  Tillman (2004)  by incorporating part-of-speech information.  Chang et al. (2009)  incorporates contexts from syntactic parse tree.  Bach et al. (2009)  exploits the dependency information and  Xiong et al. (2012)  uses the predicateargument structure.  Vaswani et al. (2011)  introduces rule markov models for a forest-to-string model in which the number of possible derivations is restricted. More recently,  Durrani et al. (2013)  and  Zhang et al. (2013)  cast reordering process as a Markov process. Similar to these models, our proposed model also provide context dependencies to the application of translation rules, however, as they focus on minimal translation units (MTU) where we focus on a selected set of translation units.  (Banchs et al., 2005)  introduces a bigram model for monotone phrasebased system, but their definition of translation units is suitable only for language pairs with limited reordering, such as translating Spanish to English. In equating anchors with the function word class, our work is closely related to the function wordcentered model of  Setiawan et al. (2007) , especially the orientation model. Our dominance model is closely related to the reordering model of  Setiawan et al. (2009) , except that they only look at pair of adjacent anchors, forming a chain structure instead of a graph like in our dominance model. Furthermore, we provide a discriminative treatment to the model to include a richer set of features including syntactic features. This work can be seen as modeling the identity of the neighboring of the anchors, similar to  (Setiawan et al., 2013) . However, instead of looking at the words at the borders, we look at whether the neighboring constituents contain other anchors. 

 Conclusion We propose the "Anchor Graph" (AG) model to encode global contextual information. A selected set of translation units, which we call anchors, serves as the vertices of AG. And as the edges, we model two types of relations, namely the dominance and the precedence relations, where the former looks at the positions of the anchors in the derivation structure, while the latter looks at the positions of the anchors in the surface structure, resulting into two probabilistic models over edge labels. As the models look at the pairs of anchors that go beyond multiple translation units, our AG model provides global contextual information. Our AG model embodies (admittedly crudely) some basic principles of sentence organization, namely categorization (in categorizing units into anchors and non-anchors), linear order (in modeling the precedence of anchors) and constituency structure (in modeling the dominance between anchors). We are encouraged by the facts that we learn these principles in an unsupervised way and that we can achieve a significant improvement over a strong baseline in a large-scale Chinese-to-English translation task. In the future, we hope to continue this line of research, perhaps by learning to identify anchors automatically from training data or by using our models to induce derivations directly from unaligned sentence pair. Figure 1 : 1 Figure 1: The illustration of the dominance and the precedence relations. The former looks at the anchors' projection on a derivation structure. The latter looks at the anchors' projection on the translated sentence. 
