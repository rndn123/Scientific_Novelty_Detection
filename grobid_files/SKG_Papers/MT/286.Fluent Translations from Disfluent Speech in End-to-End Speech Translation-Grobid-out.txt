title
Fluent Translations from Disfluent Speech in End-to-End Speech Translation

abstract
Spoken language translation applications for speech suffer due to conversational speech phenomena, particularly the presence of disfluencies. With the rise of end-to-end speech translation models, processing steps such as disfluency removal that were previously an intermediate step between speech recognition and machine translation need to be incorporated into model architectures. We use a sequence-to-sequence model to translate from noisy, disfluent speech to fluent text with disfluencies removed using the recently collected 'copy-edited' references for the Fisher Spanish-English dataset. We are able to directly generate fluent translations and introduce considerations about how to evaluate success on this task. This work provides a baseline for a new task, the translation of conversational speech with joint removal of disfluencies.

Introduction & Related Work Spoken language translation (SLT) applications suffer due to conversational speech phenomena, particularly the presence of disfluencies. In conversational speech, speakers often use disfluencies such as filler words, repetitions, false starts, and corrections which do not naturally occur in text and may not be desired in translation outputs. Disfluency recognition and removal has previously been performed as an intermediate step between speech recognition (ASR) and machine translation (MT), to make disfluent ASR output better-matched to typically clean machine translation training data  (Cho et al., 2013 (Cho et al., , 2014 Wang et al., 2010; Honal and Schultz, 2005; Zayats et al., 2016) . With the rise of end-to-end sequence-to-sequence speech translation systems  (Weiss et al., 2017; Bansal et al., 2018) , disfluency removal can no longer be handled as an intermediate step between ASR and MT but needs to be incorporated into the model or handled as a post-processing step. Generating fluent translations from disfluent speech may be desired for simultaneous SLT applications where removing disfluencies will improve the application's clarity and usability. To train endto-end speech translation requires parallel speech and text translations. This introduces data considerations not previously relevant with chained ASR+MT models, as different datasets could be used to train ASR and MT components. Where aligned speech and translations exist, data is typically clean speech clean text, as in news or TED talks, or disfluent speech disfluent translations, as in Fisher or meeting data, where disfluencies were faithfully included in the references for completeness. While some corpora with labeled disfluencies exist  (Cho et al., 2014; Burger et al., 2002) , only subsets have been translated and/or released.  Salesky et al. (2018)  introduced a set of fluent references 1 for Fisher Spanish-English, enabling a new task: end-to-end training and evaluation against fluent references. Previous work on disfluency removal has treated it as a sequence labeling task using word or spanlevel labels. However, in some cases, simply removing disfluencies from an utterance can create ill-formed output. Further, corpora can have different translation and annotation schemes: for example for Fisher Spanish-English, translated using Mechanical Turk,  Salesky et al. (2018)  found 268 unique filler words due to spelling and casing. Disfluencies can also be context-specific, such as false starts or corrections where a phrase may be 'disfluent' due to its surroundings. To remove disfluencies as a post-processing step would require a separate model trained with appropriate data and disfluency labels, and may lead to ill-formed output. By translating directly to fluent target data instead, we aim to handle these concerns implicitly. We present the first results translating directly from disfluent source speech to fluent target text. 

 Data For our experiments, we use Fisher Spanish speech  (Graff et al.)  and with two sets of English translations  (Salesky et al., 2018; Post et al., 2013) . The speech dataset comprises telephone conversations between mostly native Spanish speakers recorded in realistic noise conditions. The original English translations were collected through crowdsourcing, as described in  Post et al. (2013) . Four references were collected for each of the development and test sets, and one for training. The training data consists of 819 conversations yielding ?160 hours of speech and 150k utterances; the development and test sets are ?4k utterances each. We use only the first of the two development sets  (dev, not dev2) . This data is conversational and disfluent. The original translations faithfully maintain and translate phenomena in the Spanish transcripts such as filler words and hesitations, discourse markers (you know, well, mm), repetitions, corrections and false starts, among others.  Salesky et al. (2018)  introduced a new set of fluent reference translations collected on Mechanical Turk. They collected two references for each of the development and test sets, and one for the training set. Rather than labeling the disfluencies in the original target data, Turkers were asked to rewrite the utterance in a 'copy-edited' manner without disfluent phenomena. In some cases, simply removing disfluencies would created ill-formed structure in the resulting utterance. This scheme instead creates a sentencelevel edit allowing for reordering and insertions as necessary to create fluent content, akin instead to monolingual translation or paraphrasing. Examples of source transcripts and original translations with the fluent counterparts are shown below in Table  1 . SRC eh, eh, eh, um, yo pienso que es as? ORG uh, uh, uh, um, i think it's like that FLT i think it's like that SRC tambi?n tengo um eh estoy tomando una clase .. ORG i also have um eh i'm taking a marketing class .. FLT i'm also taking a marketing class SRC porque qu? va, mja ya te acuerda que .. ORG because what is, mhm do you recall now that .. FLT do you recall now that .. SRC y entonces am es entonces la universidad donde yo estoy es university of pennsylvania ORG and so am and so the university where i am it's the university of pennsylvania FLT i am at the university of pennsylvania Table  1 : Disfluency examples in Spanish source (SRC), original (ORG) and fluent (FLT) English translations 3 Speech-to-Text Model Initial work on the Fisher-Spanish dataset used HMM-GMM ASR models linked with phrasebased MT using lattices  (Post et al., 2013; Kumar et al., 2014) . More recently, it was shown in Weiss et al. (  2017 ) and  Bansal et al. (2018)  that end-toend SLT models perform competitively on this task. As in  Bansal et al. (2018) , we use a sequence-tosequence architecture inspired by Weiss et al. but modified to train within available resources; specifically, all models may be trained in less than 5 days on one GPU. We build an encoder-decoder model with attention in xnmt  with 512 hidden units throughout. We use a 3layer BiLSTM encoder. We do not use the additional convolutional layers from  Weiss et al. and Bansal et al.  to reduce temporal resolution, but rather use network-in-network (NiN) projections from previous work in sequence-to-sequence ASR  (Zhang et al., 2017;  to get the same total 4? downsampling in time. This gives the benefit of added depth with fewer parameters. We closely follow the LSTM/NiN encoder used in  for ASR and use the same training procedure, detailed in Appendix A. We extract 40-dimensional mel filterbank features with per-speaker mean and variance normalization with Kaldi  (Povey et al., 2011) . We did not see significant difference between 40, 40+deltas and 80-dimensional features in initial experiments, similar to  Bansal et al. (2018) , who chose 80-dim. Weiss et al. (  2017 ) used 240-dim features comprising 80-dim filterbanks stacked with deltas and delta-deltas. We exclude utterances longer than 1500 frames to manage memory requirements. Like  Weiss et al. (2017) , we translate to target characters as opposed to words  (Bansal et al., 2018) . We also use an MLP-based attention with 1 hidden layer with 128 units and 64-dimensional target embeddings, though we use only 1 decoder hidden layer as opposed to 3 or 4 in these works. We use input feeding  (Luong et al., 2015) . All models use the same preprocessing as previous work on this dataset: lowercasing and removing punctuation aside from apostrophes. 

 Experiments 

 Experimental Setup We focus on the problem of translating directly from noisy speech to clean references without a separate disfluency removal step. We first demonstrate the efficacy of our models on the original disfluent Fisher Spanish-English task, comparing to the previously reported numbers on the SLT task  (Weiss et al., 2017; Bansal et al., 2018) . We then compare these results with models trained using the collected 'clean' target data with disfluencies removed. Finally, we look at the mismatched case where we train on disfluent data and evaluate on a cleaned test set; this is a more realistic scenario, as clean training data is difficult to collect, and we cannot expect to have it for each language and use case we encounter. We evaluate using both BLEU  (Papineni et al., 2002)  and METEOR (Denkowski and Lavie, 2014) to compare different aspects of model behavior on our two tasks. 2 BLEU assesses how well predicted translations match a set of reference translations using modified n-gram precision, weighted by a brevity penalty in place of recall to penalize short hypothesis translations without full coverage. The brevity penalty is computed as e (1?r/c) , r is the length of the reference and c the candidate translation. For our task of implicitly removing disfluencies during translation, our generated translations should contain much of the same content but with certain tokens removed, creating shorter translations. When scoring fluent output against the original disfluent references, then, differences in BLEU score will come from two sources: shorter n-gram matches, and the brevity penalty. METEOR, on the other hand, can be considered a more 'semantic' evaluation metric. It uses a harmonic mean of precision and recall, with greater weight given to recall. Further, while BLEU uses exact n-gram matches, METEOR also takes into account stem, synonym, and paraphrase matches. For our fluent task, we aim to maintain semantic meaning while removing disfluent tokens. Accordingly, when scored against the fluent target references, we hope to see similar METEOR scores between the disfluent models and fluent models. Both metrics are used for a holistic view of the problem: METEOR will indicate if meaning is maintained, but not assess disfluency removal, while BLEU changes will indicate whether disfluencies have been removed. We provide both multi-reference and singlereference BLEU and METEOR scores: the original Fisher target data has four reference translations for the dev and test sets, which boosts scores considerably as hypothesis n-grams can match in any of the references. The fluent target data has two references, so the single reference scores better enable comparison between the two tasks. Comparing multi-reference scores using all four references (4Ref) vs average single reference score (1Ref). 

 Results & Discussion Table  3  compares performance of speech translation models trained with the fluent target translations to models trained with the original disfluent translations, as scored on the fluent references. Comparing the disfluent and fluent models, we see that METEOR scores are almost the same while BLEU scores are lower with the disfluent model. This is as we would hope: with our fluent model, we want to generate translations that are semantically the same but with disfluencies removed. Therefore similar METEOR scores with similar recall (52) on the fluent references are encouraging. For BLEU, however, the disfluencies generated by the disfluent model break up n-grams in the fluent references, thereby lowering scores. Comparing single-reference scores with Table  2 , we see that they are distinctly lower. This is to be expected with the shorter fluent references; a difference of a single token carries greater weight. Translating directly to the fluent references is a more challenging task. As shown in Table  1 , the original English translations and Spanish speech are very one-to-one while the edited translations introduce deletions and reorderings. In learning to generate fluent translations, the model needs to learn to handle these more inconsistent behaviors. Figure  1  shows a visual comparison between outputs generated by the two models. Using the fluent target data to train constrains the model output vocabulary, so filler words such as 'um', 'ah', 'mhm' are not generated. We also see significant reductions in repetitions of both words and phrases from the model trained with fluent reference translations. Further, we also see instances where the fluent model generates a shorter paraphrase of a disfluent phrase, as in the 2nd example. Disfluency removal for speech translation has traditionally been done as an intermediate step between ASR and MT to better-match additional clean corpora used for MT training; we do not compare to a pipeline approach here. However, to contextualize these results, we compare disfluency removal as a post-processing step after end-to-end speech translation with the original disfluent par- allel data. Simply filtering filler words and repetitions from the disfluent model (Filter) outputs as a post-processing step, the dev scores improve slightly, but test stays the same or decreases. In some cases, treating disfluency removal as a filtering task can reduce the fluency of an utterance: Disfluent mm well and from and the email is a scandal the spam. Fluent the email is a scandal it's spam. dev A filtering or tagging system may not capture all false starts or corrections, leading to lower fluency, and requires labeled spans. Treating the post-processing step as a monolingual translation task (MonoMT) rather than a filtering task allows for reordering and insertions, which we saw boost fluency. We trained a 4-layer BiLSTM encoderdecoder model to translate between the disfluent and fluent English references and applied this to the output of the end-to-end disfluent model. BLEU scores approach the results with the end-to-end fluent target model (Table  3 ), but we note, this requires the same resources as the direct task. Showing the importance of fluent references for evaluation, Table  5  shows the performance of fluent models as evaluated on the original disfluent references. Disfluent target scores are the same as in Table  2 , and have been copied for easy compar- ison. As we would expect, here there is a greater difference in scores. The fluent references have fewer long n-gram matches with disfluencies removed, lowering BLEU. The fluent model's ME-TEOR scores suffer more than BLEU due to the recall calculation; recall on the disfluent references is lower because the fluent model does not produce many of the disfluencies (indeed filler words are not in the vocabulary when trained with the fluent references). Recall is reduced by ?14% with the fluent model, reflecting the approximate distribution of disfluencies in the original data. The differences in scores with these two metrics do not show the full picture. Outputs generated by the fluent model are on average 13% shorter and contain 1.5 fewer tokens per utterance than the disfluent model, which is significant with average utterance lengths of 10-11 tokens. When scoring the fluent output against the original disfluent references, the shorter length significantly contributes to the lower scores, with the BLEU brevity penalty calculated as 0.86 as opposed to 0.96-1.0 for all other conditions. Removing the length penalty from the BLEU score calculation, single-reference scores are boosted to 19.3 and 19.8 from 16.6 and 17.0 for dev and test, respectively (Table  5 ). This is a somewhat fairer comparison of the disfluent and fluent models, as we do not want the fluent output to match the disfluent sequence length, and the disfluent models are not penalized due to length. These BLEU scores are now very similar to those of the disfluent model on the disfluent references, though the outputs are very different (Figure  1 ). The changes here and the difference in trends between the two metrics with respect to the two types of references show that evaluating this task cannot be simply accomplished with one existing metric: depending on the combination of metric and references, it's possible to mask the difference between disfluent and fluent systems, unless you have word-level disfluency annotations, which are more difficult to obtain. 

 Conclusion Machine translation applications for speech can suffer due to conversational speech phenomena, particularly the presence of disfluencies. Previous work to remove disfluencies in speech translation did so as a separate step between speech recognition and machine translation, which is not possible using end-to-end models. Using clean references for disfluent data collected by  Salesky et al. (2018) , we extend their text baseline to speech input and provide first results for direct generation of fluent text from noisy disfluent speech. While fluent training data enables research on this task with end-to-end models, it is unlikely to have this resource for every corpus and domain and it is expensive to collect. In future work, we hope to reduce the dependence on fluent target data during training through decoder pretraining on external non-conversational corpora or multitask learning. Further, standard metrics alone do not tell the full story for this task; additional work on evaluation metrics may better demonstrate the differences between such systems. ter dropout with probability 0.1  (Gal and Ghahramani, 2016) . We apply label smoothing  (Szegedy et al., 2016)  and fix the target embedding norm to 1 (Nguyen and Chiang, 2018). For inference, we use a beam size of 15 and length normalization with exponent 1.5. We set the batch size dynamically depending on the input sequence length such that the average batch size was 36. We use Adam  (Kingma and Ba, 2015)  with initial learning rate of 0.0003, and decay by 0.5 when validation BLEU did not improve first over 10 epochs and after 5 epochs after the first decay. We do not use L2 weight decay or Gaussian noise, and use a single model replica. All models use the same preprocessing as previous work on this dataset: lowercasing and removing punctuation aside from apostrophes. Figure 1 : 1 Figure 1: Comparison of example outputs generated by disfluent and fluent models, created with CharCut (Lardilleux and Lepage, 2017). 
