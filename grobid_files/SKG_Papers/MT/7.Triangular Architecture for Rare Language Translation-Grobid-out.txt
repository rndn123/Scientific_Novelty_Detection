title
Triangular Architecture for Rare Language Translation

abstract
Neural Machine Translation (NMT) performs poor on the low-resource language pair (X, Z), especially when Z is a rare language. By introducing another rich language Y , we propose a novel triangular training architecture (TA-NMT) to leverage bilingual data (Y, Z) (may be small) and (X, Y ) (can be rich) to improve the translation performance of lowresource pairs. In this triangular architecture, Z is taken as the intermediate latent variable, and translation models of Z are jointly optimized with a unified bidirectional EM algorithm under the goal of maximizing the translation likelihood of (X, Y ). Empirical results demonstrate that our method significantly improves the translation quality of rare languages on MultiUN and IWSLT2012 datasets, and achieves even better performance combining back-translation methods.

Introduction In recent years, Neural Machine Translation (NMT)  (Kalchbrenner and Blunsom, 2013; Sutskever et al., 2014; Bahdanau et al., 2014)  has achieved remarkable performance on many translation tasks  (Jean et al., 2015; Sennrich et al., 2016; Sennrich et al., 2017) . Being an end-to-end architecture, an NMT system first encodes the input sentence into a sequence of real vectors, based on which the decoder generates the target sequence word by word with the attention mechanism  (Bahdanau et al., 2014; Luong et al., 2015) . During training, NMT systems are optimized to maximize the translation probability of a given language pair * Contribution during internship at MSRA. with the Maximum Likelihood Estimation (MLE) method, which requires large bilingual data to fit the large parameter space. Without adequate data, which is common especially when it comes to a rare language, NMT usually falls short on low-resource language pairs  (Zoph et al., 2016) . In order to deal with the data sparsity problem for NMT, exploiting monolingual data  (Sennrich et al., 2015; Zhang and Zong, 2016; Cheng et al., 2016; Zhang et al., 2018;  is the most common method. With monolingual data, the back-translation method  (Sennrich et al., 2015)  generates pseudo bilingual sentences with a targetto-source translation model to train the source-totarget one. By extending back-translation, sourceto-target and target-to-source translation models can be jointly trained and boost each other  (Cheng et al., 2016; Zhang et al., 2018) . Similar to joint training  (Cheng et al., 2016; Zhang et al., 2018) , dual learning  designs a reinforcement learning framework to better capitalize on monolingual data and jointly train two models. Instead of leveraging monolingual data (X or Z) to enrich the low-resource bilingual pair (X, Z), in this paper, we are motivated to introduce another rich language Y , by which additionally acquired bilingual data (Y, Z) and (X, Y ) can be exploited to improve the translation performance of (X, Z). This requirement is easy to satisfy, especially when Z is a rare language but X is not. Under this scenario, (X, Y ) can be a rich-resource pair and provide much bilingual data, while (Y, Z) would also be a low-resource pair mostly because Z is rare. For example, in the dataset IWSLT2012, there are only 112.6K bilingual sentence pairs of English-Hebrew, since Hebrew is a rare language. If French is introduced as the third language, we can have another lowresource bilingual data of French-Hebrew (116.3K sentence pairs), and easily-acquired bilingual data of the rich-resource pair English-French. With the introduced rich language Y , in this paper, we propose a novel triangular architecture (TA-NMT) to exploit the additional bilingual data of (Y, Z) and (X, Y ), in order to get better translation performance on the low-resource pair (X, Z), as shown in Figure  1 . In this architecture, (Y, Z) is used for training another translation model to score the translation model of (X, Z), while (X, Y ) is used to provide large bilingual data with favorable alignment information. Under the motivation to exploit the richresource pair (X, Y ), instead of modeling X ? Z directly, our method starts from modeling the translation task X ? Y while taking Z as a latent variable. Then, we decompose X ? Y into two phases for training two translation models of low-resource pairs ((X, Z) and (Y, Z)) respectively. The first translation model generates a sequence in the hidden space of Z from X, based on which the second one generates the translation in Y . These two models can be optimized jointly with an Expectation Maximization (EM) framework with the goal of maximizing the translation probability p(y|x). In this framework, the two models can boost each other by generating pseudo bilingual data for model training with the weights scored from the other. By reversing the translation direction of X ? Y , our method can be used to train another two translation models p(z|y) and p(x|z). Therefore, the four translation models (p(z|x), p(x|z), p(z|y) and p(y|z)) of the rare language Z can be optimized jointly with our proposed unified bidirectional EM algorithm. Experimental results on the MultiUN and IWSLT2012 datasets demonstrate that our method can achieve significant improvements for rare languages translation. By incorporating backtranslation (a method leveraging more monolingual data) into our method, TA-NMT can achieve even further improvements. Our contributions are listed as follows: ? We propose a novel triangular training architecture (TA-NMT) to effectively tackle the data sparsity problem for rare languages in NMT with an EM framework. ? Our method can exploit two additional bilingual datasets at both the model and data levels by introducing another rich language. ? Our method is a unified bidirectional EM algorithm, in which four translation models on two low-resource pairs are trained jointly and boost each other. 

 Method As shown in Figure  1 , our method tries to leverage (X, Y ) (a rich-resource pair) and (Y, Z) to improve the translation performance of low-resource pair (X, Z), during which translation models of (X, Z) and (Y, Z) can be improved jointly. Instead of directly modeling the translation probabilities of low-resource pairs, we model the rich-resource pair translation X ? Y , with the language Z acting as a bridge to connect X and Y . We decompose X ? Y into two phases for training two translation models. The first model p(z|x) generates the latent translation in Z from the input sentence in X, based on which the second one p(y|z) generate the final translation in language Y . Following the standard EM procedure  (Borman, 2004 ) and Jensen's inequality, we derive the lower bound of p(y|x) over the whole training data D as follows: L(?; D) = (x,y)?D log p(y|x) = (x,y)?D log z p(z|x)p(y|z) = (x,y)?D log z Q(z) p(z|x)p(y|z) Q(z) ? (x,y)?D z Q(z) log p(z|x)p(y|z) Q(z) . = L(Q) (1) where ? is the model parameters set of p(z|x) and p(y|z), and Q(z) is an arbitrary posterior distribution of z. We denote the lower-bound in the last but one line as L(Q). Note that we use an approximation that p(y|x, z) ? p(y|z) due to the semantic equivalence of parallel sentences x and y. In the following subsections, we will first propose our EM method in subsection 2.1 based on the lower-bound derived above. Next, we will extend our method to two directions and give our unified bidirectional EM training in subsection 2.2. Then, in subsection 2.3, we will discuss more training details of our method and present our algorithm in the form of pseudo codes. 

 EM Training To maximize L(?; D), the EM algorithm can be leveraged to maximize its lower bound L(Q). In the E-step, we calculate the expectation of the variable z using current estimate for the model, namely find the posterior distribution Q(z). In the M-step, with the expectation Q(z), we maximize the lower bound L(Q). Note that conditioned on the observed data and current model, the calculation of Q(z) is intractable, so we choose Q(z) = p(z|x) approximately. M-step: In the M-step, we maximize the lower bound L(Q) w.r.t model parameters given Q(z). By substituting Q(z) = p(z|x) into L(Q), we can get the M-step as follows: ? y|z = arg max ? y|z L(Q) = arg max ? y|z (x,y)?D z p(z|x) log p(y|z) = arg max ? y|z (x,y)?D E z?p(z|x) log p(y|z) (2) E-step: The approximate choice of Q(z) brings in a gap between L(Q) and L(?; D), which can be minimized in the E-step with Generalized EM method  (McLachlan and Krishnan, 2007) . According to  Bishop (2006) , we can write this gap explicitly as follows: L(?; D) ? L(Q) = z Q(z) log Q(z) p(z|y) = KL(Q(z)||p(z|y)) = KL(p(z|x)||p(z|y)) (3) where KL(?) is the KullbackLeibler divergence, and the approximation that p(z|x, y) ? p(z|y) is also used above. In the E-step, we minimize the gap between L(Q) and L(?; D) as follows: ? z|x = arg min ? z|x KL(p(z|x)||p(z|y)) (4) To sum it up, the E-step optimizes the model p(z|x) by minimizing the gap between L(Q) and L(?; D) to get a better lower bound L(Q). This lower bound is then maximized in the M-step to optimize the model p(y|z). Given the new model p(y|z), the E-step tries to optimize p(z|x) again to find a new lower bound, with which the M-step is re-performed. This iteration process continues until the models converge, which is guaranteed by the convergence of the EM algorithm. 

 Unified Bidirectional Training The model p(z|y) is used as an approximation of p(z|x, y) in the E-step optimization (Equation  3 ). Due to the low resource property of the language pair (Y, Z), p(z|y) cannot be well trained. To solve this problem, we can jointly optimize p(x|z) and p(z|y) similarly by maximizing the reverse translation probability p(x|y). We now give our unified bidirectional generalized EM procedures as follows: ? Direction of X ? Y E: Optimize ? z|x . arg min ? z|x 

 KL(p(z|x)||p(z|y)) (5) M: Optimize ? y|z . arg max ? y|z (x,y)?D E z?p(z|x) log p(y|z) (6) ? Direction of Y ? X E: Optimize ? z|y . arg min ? z|y KL(p(z|y)||p(z|x)) (7) M: Optimize ? x|z . arg max ? x|z (x,y)?D E z?p(z|y) log p(x|z) (8) Based on the above derivation, the whole architecture of our method can be illustrated in Figure  2 , where the dash arrows denote the direction of p(y|x), in which p(z|x) and p(y|z) are trained jointly with the help of p(z|y), while the solid ones denote the direction of p(x|y), in which p(z|y) and p(x|z) are trained jointly with the help of p(z|x).  

 Training Details A major difficulty in our unified bidirectional training is the exponential search space of the translation candidates, which could be addressed by either sampling  (Shen et al., 2015; Cheng et al., 2016)  or mode approximation  (Kim and Rush, 2016) . In our experiments, we leverage the sampling method and simply generate the top target sentence for approximation. In order to perform gradient descend training, the parameter gradients for Equations 5 and 7 are formulated as follows: ? ? z|x KL(p(z|x)||p(z|y)) = E z?p(z|x) log p(z|x) p(z|y) ? ? z|x log p(z|x) ? ? z|y KL(p(z|y)||p(z|x)) = E z?p(z|y) log p(z|y) p(z|x) ? ? z|y log p(z|y) (9) Similar to reinforcement learning, models p(z|x) and p(z|y) are trained using samples generated by the models themselves. According to our observation, some samples are noisy and detrimental to the training process. One way to tackle this is to filter out the bad ones using some additional metrics (BLEU, etc.). Nevertheless, in our settings, BLEU scores cannot be calculated during training due to the absence of the golden targets (z is generated based on x or y from the richresource pair (x, y)). Therefore we choose IBM model1 scores to weight the generated translation candidates, with the word translation probabilities calculated based on the given bilingual data (the low-resource pair (x, z) or (y, z)). Additionally, to stabilize the training process, the pseudo samples generated by model p(z|x) or p(z|y) are mixed with true bilingual samples in the same mini-batch with the ratio of 1-1. The whole training procedure is described in the following Algorithm 1, where the 5th and 9th steps are generating pseudo data.   7 ) 11: M-step: update ? x|z with B 4 (Equation  8 ) 12: end while 13: return ? z|x , ? y|z , ? z|y and ? x|z 3 Experiments 

 Datasets In order to verify our method, we conduct experiments on two multilingual datasets. The one is MultiUN  (Eisele and Chen, 2010) , which is a collection of translated documents from the United Nations, and the other is IWSLT2012  (Cettolo et al., 2012) , which is a set of multilingual transcriptions of TED talks. As is mentioned in section 1, our method is compatible with methods exploiting monolingual data. So we also find some extra monolingual data of rare languages in both datasets and conduct experiments incorporating back-translation into our method. MultiUN: English-French (EN-FR) bilingual data are used as the rich-resource pair (X, Y ). Arabic (AR) and Spanish (ES) are used as two simulated rare languages Z. We randomly choose subsets of bilingual data of (X, Z) and (Y, Z) in the original dataset to simulate low-resource situations, and make sure there is no overlap in Z between chosen data of (X, Z) and (Y, Z). IWSLT2012 1 : English-French is used as the rich-resource pair (X, Y ), and two rare languages Z are Hebrew (HE) and Romanian (RO) in our choice. Note that in this dataset, low-resource pairs (X, Z) and (Y, Z) are severely overlapped in Z. In addition, English-French bilingual data from WMT2014 dataset are also used to enrich the rich-resource pair. We also use additional English-Romanian bilingual data from Europarlv7 dataset  (Koehn, 2005) . The monolingual data of Z (HE and RO) are taken from the web 2 . In both datasets, all sentences are filtered within the length of 5 to 50 after tokenization. Both the validation and the test sets are 2,000 parallel sentences sampled from the bilingual data, with the left as training data. The size of training data of all language pairs are shown in Table  1 . 

 Baselines We compare our method with four baseline systems. The first baseline is the RNNSearch model  (Bahdanau et al., 2014) , which is a sequence-tosequence model with attention mechanism trained with given small-scale bilingual data. The trained translation models are also used as pre-trained models for our subsequent training processes. The second baseline is PBSMT  (Koehn et al., 2003) , which is a phrase-based statistical machine translation system. PBSMT is known to perform well on low-resource language pairs, so we want to compare it with our proposed method. And we use the public available implementation of Moses 5 for training and test in our experiments. The third baseline is a teacher-student alike method  (Chen et al., 2017) . For the sake of brevity, we will denote it as T-S. The process is illustrated in Figure  3 . We treat this method as a second baseline because it can also be regarded as a method exploiting (Y, Z) and (X, Y ) to improve The fourth baseline is back-translation  (Sennrich et al., 2015) . We will denote it as Back-Trans. More concretely, to train the model p(z|x), we use extra monolingual Z described in Table  1  to do back-translation; to train the model p(x|z), we use monolingual X taken from (X, Y ). Procedures for training p(z|y) and p(y|z) are similar. This method use extra monolingual data of Z compared with our TA-NMT method. But we can incorporate it into our method.  

 Overall Results Experimental results on both datasets are shown in Table  3  and 4 respectively, in which RNNSearch, PBSMT, T-S and BackTrans are four baselines. TA-NMT is our proposed method, and TA-NMT(GI) is our method incorporating backtranslation as good initialization. For the purpose of clarity and a fair comparison, we list the resources that different methods exploit in Table  2 . From Table  3    for both (X, Z) and (Y, Z) by generating pseudo data from each other, leads up to 1.1 BLEU points improvement on average over RNNSearch. Compared with T-S, our method gains a further improvement of about 0.9 BLEU on average, because our method can better leverage the rich-resource pair (X, Y ). With extra large monolingual Z introduced, BackTrans can improve the performance of p(z|x) and p(z|y) significantly compared with all the methods without monolingual Z. However TA-NMT is comparable with or even better than BackTrans for p(x|z) and p(y|z) because both of the methods leverage resources from richresource pair (X, Y ), but BackTrans does not use the alignment information it provides. Moreover, with back-translation as good initialization, further improvement is achieved by TA-NMT(GI) of about 0.7 BLEU on average over BackTrans. In Table  4 , we can draw the similar conclusion. However, different from MultiUN, in the EN-FR-HE group of IWSLT, (X, Z) and (Y, Z) are severely overlapped in Z. Therefore, T-S cannot improve the performance obviously (only about 0.2 BLEU) on RNNSearch because it fails to essentially double training data via the teacher model. As for EN-FR-RO, with the additionally introduced EN-RO data from Europarlv7, which has no overlap in RO with FR-RO, T-S can improve the average performance more than the EN-FR-HE group. TA-NMT outperforms T-S by 0.93 BLEU on average. Note that even though Back-Trans uses extra monolingual Z, the improvements are not so obvious as the former dataset, the reason for which we will delve into in the next subsection. Again, with back-translation as good initialization, TA-NMT(GI) can get the best result. Note that BLEU scores of TA-NMT are lower than BackTrans in the directions of X?Z and Y?Z. The reason is that the resources used by these two methods are different, as shown in Table  2 . To do back translation in two directions (e.g., X?Z and Z?X), we need monolingual data from both sides (e.g., X and Z), however, in TA-NMT, the monolingual data of Z is not necessary. Therefore, in the translation of X?Z or Y?Z, Back-Trans uses additional monolingual data of Z while TA-NMT does not, that is why BackTrans outperforms TA-NMT in these directions. Our method can leverage back translation as a good initialization, aka TA-NMT(GI) , and outperforms Back-Trans on all translation directions. The average test BLEU scores of different methods in each data group (EN-FR-AR, EN-FR-ES, EN-FR-HE, and EN-FR-RO) are listed in the column Ave of the tables for clear comparison. 

 The Effect of Extra Monolingual Data Comparing the results of BackTrans and TA-NMT(GI) on both datasets, we notice the improvements of both methods on IWSLT are not as significant as MultiUN. We speculate the reason is the relatively less amount of monolingual Z we use in the experiments on IWSLT as shown in Table  1 . So we conduct the following experiment to verify the conjecture by changing the scale of monolingual Arabic data in the MultiUN dataset, of which the data utilization rates are set to 0%, 10%, 30%, 60% and 100% respectively. Then we compare the performance of BackTrans and TA-NMT(GI) in the EN-FR-AR group. As Figure  4  shows, the amount of monolingual Z actually has a big effect on the results, which can also verify our conjecture above upon the less significant improvement of BackTrans and TA-NMT(GI) on IWSLT. In addition, even with poor "good-initialization", TA-NMT(GI) still get the best results.  

 EM Training Curves To better illustrate the behavior of our method, we print the training curves in both the M-steps and Esteps of TA-NMT and TA-NMT(GI) in Figure  5  above. The chosen models printed in this figure are EN2AR and AR2FR on MultiUN, and EN2RO and RO2FR on IWLST. From Figure  5 , we can see that the two lowresource translation models are improved nearly simultaneously along with the training process, which verifies our point that two weak models could boost each other in our EM framework. Notice that at the early stage, the performance of all models stagnates for several iterations, especially of TA-NMT. The reason could be that the pseudo bilingual data and the true training data are heterogeneous, and it may take some time for the models to adapt to a new distribution which both models agree. Compared with TA-NMT, TA-NMT(GI) are more stable, because the models may have adapted to a mixed distribution of heterogeneous data in the preceding back-translation phase. 

 Reinforcement Learning Mechanism in Our Method As shown in Equation  9 , the E-step actually works as a reinforcement learning (RL) mechanism. Models p(z|x) and p(z|y) generate samples by themselves and receive rewards to update their parameters. Note that the reward here is described by the log terms in Equation  9 , which is derived from our EM algorithm rather than defined artificially. In Table  5 , we do a case study of the EN2ES translation sampled by p(z|x) as well as its time-step rewards during the E-step. In the first case, the best translation of "political" is "pol?ticos". When the model p(z|x) generates an inaccurate one "pol?ticas", it receives a negative reward (-0.01), with which the model parameters will be updated accordingly. In the sec-Source in concluding , poverty eradication requires political will and commitment . Output en (0.66) conclusi?n (0.80) , (0.14) la (0.00) erradicaci?n (1.00) de (0.40) la (0.00) pobreza (0.90) requiere (0.10) voluntad (1.00) y (0.46) compromiso (0.90) pol?ticas (-0.01) . (1.00) Reference en conclusi?n , la erradicaci?n de la pobreza necesita la voluntad y compromiso pol?ticos . Source visit us and get to know and love berlin ! Output visita (0.00) y (0.05) se (0.00) a (0.17) saber (0.00) y (0.04) a (0.01) berl?n (0.00) ! (0.00) Reference vis?tanos y llegar a saber y amar a berl?n . Source legislation also provides an important means of recognizing economic , social and cultural rights at the domestic level . Table  5 : English to Spanish translation sampled in the E-step as well as its time-step rewards. ond case, the output misses important words and is not fluent. Rewards received by the model p(z|x) are zero for nearly all tokens in the output, leading to an invalid updating. In the last case, the output sentence is identical to the human reference. The rewards received are nearly all positive and meaningful, thus the RL rule will update the parameters to encourage this translation candidate. 

 Related Work NMT systems, relying heavily on the availability of large bilingual data, result in poor translation quality for low-resource pairs  (Zoph et al., 2016) . This low-resource phenomenon has been observed in much preceding work. A very common approach is exploiting monolingual data of both source and target languages  (Sennrich et al., 2015; Zhang and Zong, 2016; Cheng et al., 2016; Zhang et al., 2018; . As a kind of data augmentation technique, exploiting monolingual data can enrich the training data for low-resource pairs.  Sennrich et al. (2015)  propose back-translation, exploits the monolingual data of the target side, which is then used to generate pseudo bilingual data via an additional target-to-source translation model. Different from back-translation,  Zhang and Zong (2016)  propose two approaches to use source-side monolingual data, of which the first is employing a self-learning algorithm to generate pseudo data, while the second is using two NMT models to predict the translation and to reorder the source-side monolingual sentences. As an extension to these two methods,  Cheng et al. (2016)  and  Zhang et al. (2018)  combine two translation directions and propose a training framework to jointly optimize the sourceto-target and target-to-source translation models. Similar to joint training,  propose a dual learning framework with a reinforcement learning mechanism to better leverage monolingual data and make two translation models promote each other. All of these methods are concentrated on exploiting either the monolingual data of the source and target language or both of them. Our method takes a different angle but is compatible with existing approaches, we propose a novel triangular architecture to leverage two additional language pairs by introducing a third rich language. By combining our method with existing approaches such as back-translation, we can make a further improvement. Another approach for tackling the low-resource translation problem is multilingual neural machine translation  (Firat et al., 2016) , where different encoders and decoders for all languages with a shared attention mechanism are trained. This method tends to exploit the network architecture to relate low-resource pairs. Our method is different from it, which is more like a training method rather than network modification. 

 Conclusion In this paper, we propose a triangular architecture (TA-NMT) to effectively tackle the problem of low-resource pairs translation with a unified bidirectional EM framework. By introducing another rich language, our method can better exploit the additional language pairs to enrich the original low-resource pair. Compared with the RNNSearch  (Bahdanau et al., 2014) , a teacherstudent alike method  (Chen et al., 2017)  and the back-translation  (Sennrich et al., 2015)  on the same data level, our method achieves significant improvement on the MutiUN and IWSLT2012 datasets. Note that our method can be combined with methods exploiting monolingual data for NMT low-resource problem such as backtranslation and make further improvements. In the future, we may extend our architecture to other scenarios, such as totally unsupervised training with no bilingual data for the rare language. Figure 1 : 1 Figure 1: Triangular architecture for rare language translation. The solid lines mean rich-resource and the dash lines mean low-resource. X, Y and Z are three different languages. 
