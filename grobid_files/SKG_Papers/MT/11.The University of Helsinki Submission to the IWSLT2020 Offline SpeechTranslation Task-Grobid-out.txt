title
The University of Helsinki submission to the IWSLT2020 Offline Speech Translation Task

abstract
This paper describes the University of Helsinki Language Technology group's participation in the IWSLT 2020 offline speech translation task, addressing the translation of English audio into German text. In line with this year's task objective, we train both cascade and endto-end systems for spoken language translation. We opt for an end-to-end multitasking architecture with shared internal representations and a cascade approach that follows a standard procedure consisting of ASR, correction, and MT stages. We also describe the experiments that served as a basis for the submitted systems. Our experiments reveal that multitasking training with shared internal representations is not only possible but allows for knowledge-transfer across modalities.

Introduction An effective solution for performing spoken language translation (SLT) must deal with the evident challenge of transferring the implicit semantics between audio and text modalities. An end-to-end SLT system must hence appropriately address this problem while simultaneously performing accurate machine translation (MT)  (Sulubacak et al., 2018) . In last year's IWSLT challenge, both end-toend and cascade systems yielded similar results  (Niehues et al., 2019) . It follows that this year's IWSLT offline speech translation challenge focuses on whether "the cascaded solution is still the dominant technology in spoken language translation"  (Ansari et al., 2020) . For our participation on this task, we train both cascade and end-to-end systems for SLT. For the end-to-end system, we use a multimodal approach trained in a multitask fashion, which maps the internal representations of different encoders into a shared space before decoding. For the cascade approach, we use a pipeline of three stages: (i) automatic speech recognition (ASR), (ii) punctuation and letter-case restoration, and (iii) MT. We focus on exploiting the knowledge-transfer capabilities of a multitasking architecture based on language-specific encoders-decoders  (Lu et al., 2018; Schwenk and Douze, 2017; Luong et al., 2016) . This idea has been proposed and studied in the multilingual scenario  (V?zquez et al., 2020; Subramanian et al., 2018; Firat et al., 2017) , however, we adapt it to be used in a multimodal scenario. Regarding different modalities (in this case, audio and text) as different languages when training the model, allows us to employ a cross-modal intermediate shared layer for performing SLT in an end-to-end fashion. By jointly training this layer, we aim for the the model to combine the semantic information provided in the text-to-text MT tasks with the ability to generate text from audio in the ASR tasks. 

 Proposed Systems End-to-end SLT We use an inner-attention based architecture proposed by  V?zquez et al. (2020) . In a nutshell, it follows the conventional structure of an encoderdecoder model of MT  (Bahdanau et al., 2015; Luong et al., 2016)  enabled with multilingual training by incorporating language-specific encoders and decoders trainable with a language-rotating scheduler  (Dong et al., 2015; Schwenk and Douze, 2017) , and an intermediate shared inner-attention layer  (C?fka and Bojar, 2018; Lu et al., 2018) . We implement our model on top of an OpenNMT-py  (Klein et al., 2017)  fork, which we make available for reproducibility purposes.  1  The text encoders and the decoders (always text output) are transformers  (Vaswani et al., 2017) . We implement the transformer-based audio encoders inspired by the SLT architecture with tied layer structure from  Tu et al. (2019)  and the R-Transformer from Di  Gangi et al. (2019b) . It consists of n CNN layers; the first one taking k stacked Mel filterbank features as input channels, and the following ones 32 input channels. Afterwards, a linear layer corrects the shape of the embeddings and is concatenated with the positional embeddings to be fed as input to m transformer layers. Given the multimodal nature of the task, we modified the source-target rotating scheduler. Instead of a uniform distribution over the language pairs, we propose using a weighted sampling scheme based on the inverse of the batch size of the modalities. This modification allows us to have a more balanced training because audio inputs tend to be considerably longer than text inputs, and a transformerbased encoder could not possibly handle the 4096 tokens conventionally used as the ad-hoc choice of batch size for a text-based transformer. 

 Cascade approach The ASR stage of our pipeline is trained with an S-Transformer  (Di Gangi et al., 2019b) ; an adaptation of the transformer architecture to end-to-end SLT. The encoder in this architecture makes it possible to process audio features. It consists of two 2dimensional CNN-blocks meant to downsample the input, followed by two 2-dimensional self-attention layers to model the long-range context, an attention layer that concatenates its output with the positional encodings of the input, and six transformer-based layers. The output of the ASR stage is followed by the restoration stage for punctuation and letter case restoration. Since the training data for the ASR model mixes different training sets with different formatting, the raw output from the ASR block can have stylistic differences from the input seen during the training of the translation stage. The restoration stage involves the use of an auxiliary transformerbased MT model to perform "intralingual translation" from lowercased text without punctuation into fully-cased and punctuated text. Stripping punctuation on the ASR output, converting the text to lowercase, and processing the result through the restoration stage ensures that the output conforms to the same format that the translation stage was optimized for. As the last step, the translation stage uses an-other transformer to translate the processed ASR output to German. Both this transformer model and the one used in the restoration stage are based on the freely available Marian NMT implementation  (Junczys-Dowmunt et al., 2018) . Our configuration uses a learning rate of 0.0003 with linear warmup through the first 16 000 batches, decaying afterwards. The decoder normalizes scores by translation length (normalization exponent of 1.0) during beam search. All other options use the default values. 

 Data Preprocessing The Data for the end-to-end SLT system. We use Europarl-ST (Iranzo-S?nchez et al.), IWSLT2018  (Niehues et al., 2019)  and  MuST-C (Di Gangi et al., 2019a) , a total of 433k utterances after cleaning some corrupt files or with other problems in the sampling. We extracted 80-dimensional Mel filterbank features for each sentence-like segment using our own implementation. Text data for the end-to-end SLT system. For the text data of the multimodal end-to-end SLT system, we use a total of ?51M sentence pairs from corpora specified in Table  2 . Instead of using all of this data, we first filter out noisy translations. OpenSubtitles2018, which consists of subtitle translations, and corpora gathered by crawling the internet, Common Crawl and ParaCrawl, are especially likely to contain noisy data. For filtering the corpora, we utilize OpusFilter  (Aulamo et al., 2020) , a toolbox for creating clean parallel corpora. First, we extract six feature values for each of the sentence pairs. In particular, we apply the following features: CharacterScore, CrossEntropy, LanguageID, NonZeroNumeral, TerminalPunctuation and WordAlign, each of which is defined in  Aulamo et al. (2020) . Secondly, we train a logistic regression classifier based on those features. The classifier is trained only on WIT 3 , MuST-C, Europarl-ST and IWSLT18, which are multimodal datasets with speech-to-text and text-to-text data. This allows the system to adapt to text translations that are associated with speech translations. Finally, we use the classifier to assign a cleanness score ranging from 0 to 1 for all sentence pairs in all corpora. The data is then ranked based on the cleanness score, after which a portion of noisy pairs is removed from the tail. Our preliminary translation experiments showed that removing up to 40% of the data improves the translation quality, leaving us ?30.5M sentence pairs of training data, which are then used in all our end-to-end experiments.  Audio for the cascade system. We have extracted 40-dimensional Filterbank features with speaker normalization for each sentence-like segment of the MuST-C, How2  (Sanabria et al., 2018)  and Mozilla Common Voice  (Ardila et al., 2019)  corpora using XNMT  (Neubig et al., 2018) . 

 Corpora After getting rid of audio files that were too short (less than 0.4 seconds), corrupted, or no longer available for download from YouTube, some 1.2M clean utterances remained for training the ASR system, and 30k for validation. On the target side, we use two contrastive preprocessing pipelines: Text data for the cascade system. In our SLT pipeline, the data we applied for our restoration and translation models have some overlap and some differences. Initially, we "clean" the output of our ASR model to remove segments containing musical note characters ( ), and repeating phrases that were consistently hallucinated during silence, applause, laughter or noise in the audio (e.g. in our case, "Shake. Fold."), as well as parts of segments that designate the speaker (e.g. "Audience: ..."). Subsequently, we use the same preprocessing pipeline for the cleaned ASR output as we do for all of our text data. For this, we start by removing nonprinting characters, normalizing punctuation, and retokenizing the text using the corresponding utilities from the Moses toolkit  (Koehn et al., 2007) . Afterwards, we apply subword segmentation via SentencePiece  (Kudo and Richardson, 2018) , using a joint English-German BPE model with a vocabulary size of 32 000 for all of our translation models, and an English unigram model with a vocabulary size of 24 000 for the restoration stage of our cascade SLT, both trained on all of the data used for the translation and restoration models combined. Before the training of the restoration model, the training data was run through a Moses truecaser model (trained on the same selection of training data as the restoration model) as an additional step before segmentation. This step removes sentenceinitial capitalization for words that would not be capitalized otherwise, ensuring that differences in distributions of words appearing in sentence-initial positions does not influence case restoration for the model. Once truecased and segmented, we assign the processed data as the target for the restoration model, and continue to strip punctuation and lowercase the target to generate the source. This configuration comes with the useful side effect of the model learning to generate truecased output, which may be beneficial for MT. 

 Experiments In this section we report on the experiments that lead up to our final submissions. The experiments on this section have been trained, validated and tested on the respective splits of the MuST-C dataset. As a first stage, we focused on selecting the multitask training strategy that performed better. Having the three modalities ENAUDIO, ENTEXT and DETEXT as possible inputs, and both text modalities as possible outputs, there can be up to 64 combinations where audio is an input 2 without taking into account the cases where the text encoder is shared between German and English. We considered the 5 scenarios depicted in Figure  1  and present its results in Table  3  together with the number of steps it took for them to converge. All the models were trained using the same set of hyperparameters. At the time we ran these experiments, the final version of the audio encoder was not ready for deployment, so we used a 4-layered pyramidal CNN+RNN encoder adaptation from  Amodei et al. (2016)  with 512 hidden units and pooling factors of (1,1,2,2) after each layer, respectively. For the text encoders, we applied embedding layers of 512 dimensions, four stacked bidirectional LSTM layers with 512 hidden units (256 per direction). We use attentive text decoders composed of two unidirectional LSTM layers with 512 units. Regarding the shared attention bridge layer, we used 100 attention heads with 1024 hidden units each. Training is performed using the Adam optimizer (Kingma and Ba, 2015) with a learning rate of 0.0002 and batch size 32 for all source-target pairs, for at most 100,000 steps per language pair 3 . At this stage, we apply a uniform language-rotating scheduler. Isolating the effect of multitasking from the effect of weighting the scheduling distribution helped us understand the importance of weighting it with respect to the batch size.  Our preliminary BLEU scores 4 for these models are low. We, however, justify our choice to include them given the low performance of other experiments in similar scenarios reported in the literature. Namely,  Tu et al. (2019)   The well-known sensitivity to hyperperparameter choice of the transformer architecture is also visible in our transformer-based audio encoders. We performed hyperparameter tuning on opt3 multitask training configuration (Figure  1 (d) ). This resulted in a performance of a 9.53 BLEU score on German translations and 47.63 on the English, a clear increase from the untuned models that got at most 1 BLEU point in any of them. The final hyperparameter setup consists of: 

 Configuration ? text encoders and decoders using 3 layered transformer architecture with 8 heads, 512 dimensional embeddings, 2048 feedforward hidden dimensions, and a batch size of 4096 tokens; ? audio encoders as described in Section 2 with 2 CNN layers with stride of 2 and kernel width of, the first of which takes a single input channel, three 8-headed transformer layers, positional embeddings of size 512 concatenated to the output of a linear layer for being passed to the transformer layers, a batch size of 32 utterances; and ? an attention bridge of size 100 with a hidden dimension of 1024. Training was done with 8,000 warmup steps, using an Adam optimizer with learning rate 2 and Noam decay method, accumulation count of 8 to have an approximate effective batch size of 256 for the audio utterances, dropping utterances above the length of 5500, and a language rotating scheduler that uses the inverse of the batch size as weights 5 . We also tried other strategies such as (i) using 3, 4 and 6 stacked filterbanks as different channel inputs for the CNNs to reduce the input size instead of dropping utterances, (ii) using SpecAugment  (Park et al., 2019)  layers (2 frequency masks of width 20 and 2 time masks of width 50) to produce a data augmentation effect while training, (iii) including layer normalization after the attention bridge, (iv) using the positional embeddings of our transformer-based audio encoder in other places of the encoder or not using them at all. Unfortunately, none of them produced as effective improvements as what we describe above. We note that it is probable that using milder hyperparameters for SpecAugment could be beneficial. 

 Results From the insights gained out of our experiments on the MuST-C dataset, for our submission, we train a system using the data as described in section 3 with the training configuration opt3 (see Figure  1 (d) ) and the hyperparameters that yielded the best results. Further, we decided to try out an additional training configuration we had not previously tried out: ENAUDIO as input and DETEXT and ENTEXT as output, which we refer to as opt6. Configurations from Figure  1  use both modalities as input, whereas opt6 separates them by using onlyaudio input and only-text output. This might be the reason why opt6 outperformed them when tested on the MuST-C test set. Further experimentation would be required to make this statement conclusive. One of our main aims in participating in this task is to test our multitask architecture; for this reason we submit our best SLT system as primary system and the cascade approach with subword segmentation as contrastive baseline. We would like to note that, unfortunately, at the time of submission, our end-to-end systems had not converged yet. For the sake of consistency, these have been benchmarked with the MuST-C test set as well. The results are reported in Table  4 , where we also report BLEU and WER for English, corresponding to the ASR task. 

 Conclusion In this paper we present our work for the IWSLT2020 offline speech translation task, along with the set of experiments that led to our final systems. Our submission includes both a cascaded baseline and a multimodal system trainable in a multitask fashion. Our work shows that it is possible to train a system that shares internal representations for transferring the implicit semantics between audio and text modalities. The nature of the architecture enables end-to-end SLT, while at the same time providing a system capable of performing ASR and MT. Although this represents an important step in multimodal MT, there is still a lot of room for improvement in the proposed systems. In future work, we would like to implement more sophisticated audio encoders, such as the S-Transformer. This, along with using the same amount of data during training, will allow us to draw a truly fair comparison between both end-toend and cascade approaches. i) the same subword segmentation used for the MT system _it _& apos ; s _a _lobster _made _of _play d ough _that _& apos ; s _afraid _of _the _dark _. ii) character level segmentation I t <space> ' s <space> a <space> l o b s t e r <space> m a d e <space> o f <space> p l a y d o u g h <space> t h a t <space> ' s <space> a f r a i d <space> o f <space> t h e <space> d a r k <space> . 
