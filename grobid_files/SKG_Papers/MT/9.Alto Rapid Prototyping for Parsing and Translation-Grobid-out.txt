title
Alto: Rapid Prototyping for Parsing and Translation

abstract
We present Alto, a rapid prototyping tool for new grammar formalisms. Alto implements generic but efficient algorithms for parsing, translation, and training for a range of monolingual and synchronous grammar formalisms. It can easily be extended to new formalisms, which makes all of these algorithms immediately available for the new formalism.

Introduction Whenever a new grammar formalism for natural language is developed, there is a prototyping phase in which a number of standard algorithms for the new formalism must be worked out and implemented. For monolingual grammar formalisms, such as (probabilistic) context-free grammar or tree-adjoining grammar, these include algorithms for chart parsing and parameter estimation. For synchronous grammar formalisms, we also want to decode inputs into outputs, and binarizing grammars becomes nontrivial. Implementing these algorithms requires considerable thought and effort for each new grammar formalism, and can lead to faulty or inefficient prototypes. At the same time, there is a clear sense that these algorithms work basically the same across many different grammar formalisms, and change only in specific details. In this demo, we address this situation by introducing Alto, the Algebraic Language Toolkit. Alto is based on Interpreted Regular Tree Grammars (IRTGs;  (Koller and Kuhlmann, 2011) ), which separate the derivation process (described by probabilistic regular tree grammars) from the interpretation of a derivation tree into a value of the language. In this way, IRTGs can capture a wide variety of monolingual and synchronous grammar formalisms (see Fig.  1  for some examples). By selecting an appropriate algebra in which the values of the language are constructed, IRTGs can describe languages of objects that are not strings, including string-to-tree and tree-to-tree mappings, which have been used in machine translation, and synchronous hyperedge replacement grammars, which are being used in semantic parsing. One advantage of IRTGs is that a variety of algorithms, including the ones listed above, can be expressed generically in terms of operations on regular tree grammars. These algorithms apply identically to all IRTG grammars and Alto offers optimized implementations. Only an algebraspecific decomposition operation is needed for each new algebra. Thus prototyping for a new grammar formalism amounts to implementing an appropriate algebra that captures new interpretation operations. All algorithms in Alto then become directly available for the new formalism, yielding an efficient prototype at a much reduced implementation effort. Alto is open source and regularly adds new features. It is available via its website: https://bitbucket.org/tclup/alto. 

 An example grammar Let us look at an example to illustrate the Alto workflow. We will work with a synchronous string-to-graph grammar, which Alto's GUI displays as in Fig.  2 . The first and second column describe a weighted regular tree grammar (wRTG,  (Comon et al., 2007) ), which specifies how to rewrite nonterminal symbols such as S and NP recursively in order to produce derivation trees. For instance, the tree shown in the leftmost panel of Fig.  3  can be derived using this grammar, starting with the start symbol S, and is assigned a weight (= probability) of 0.24. These derivation trees Formalism Reference Algebra(s) Context-Free Grammars (CFGs)  (Hopcroft and Ullman, 1979 ) String Hyperedge Replacement Grammars (HRGs)  (Chiang et al., 2013)  Graph Tree Substitution Grammars  (Sima'an et al., 1994)  String / Tree Tree-Adjoining Grammars (TAGs)  (Joshi et al., 1975)  TAG string / TAG tree Synchronous CFGs  (Chiang, 2007)  String / String Synchronous HRGs  (Chiang et al., 2013)  String / Graph String to Tree Transducer  (Galley et al., 2004)  String / Tree Tree to Tree Transducer  (Graehl et al., 2008)  Tree / Tree Figure  1 : Some grammar formalisms that Alto can work with. serve as abstract syntactic representations, along the lines of derivation trees in TAG. Next, notice the column "english" in Fig.  2 . This column describes how to interpret the derivation tree in an interpretation called "english". It first specifies a tree homomorphism, which maps derivation trees into terms over some algebra by applying certain rewrite rules bottom-up. For instance, the "boy" node in the example derivation tree is mapped to the term t 1 = * (the, boy). The entire subtree then maps to a term of the form * (?1, * (wants, * (to, ?2))), as specified by the row for "wants2" in the grammar, where ?1 is replaced by t 1 and ?2 is replaced by the analogous term for "go". The result is shown at the bottom of the middle panel in Fig.  3 . Finally, this term is evaluated in the underlying algebra; in this case, a simple string algebra, which interprets the symbol * as string concatenation. Thus the term in the middle panel evaluates to the string "the boy wants to go", shown in the "value" field. The example IRTG also contains a column called "semantics". This column describes a second interpretation of the derivation tree, this time into an algebra of graphs. Because the graph algebra is more complex than the string algebra, the function symbols look more complicated. However, the general approach is exactly the same as before: the grammar specifies how to map the derivation tree into a term (bottom of rightmost panel in Fig.  3 ), and then this term is evaluated in the respective algebra (here, the graph shown at the top of the rightmost panel). Thus the example grammar is a synchronous grammar which describes a relation between strings and graphs. When we parse an input string w, we compute a parse chart that describes all grammatically correct derivation trees that interpret to this input string. We do this by computing a decomposition grammar for w, which describes all terms over the string algebra that evaluate to w; this step is algebra-specific. From this, we calculate a regular tree grammar for all derivation trees that the homomorphism maps into such a term, and then intersect it with the wRTG. These operations can be phrased in terms of generic operations on RTGs; implementing these efficiently is a challenge which we have tackled in Alto. We can compute the best derivation tree from the chart, and map it into an output graph. Similarly, we can also decode an input graph into an output string. 

 Algorithms in Alto Alto can read IRTG grammars and corpora from files, and implements a number of core algorithms, including: automatic binarization of monolingual and synchronous grammars  (B?chse et al., 2013) ; computation of parse charts for given input objects; computing the best derivation tree; computing the k-best derivation trees, along the lines of  (Huang and Chiang, 2005) ; and decoding the best derivation tree(s) into output interpretations. Alto supports PCFG-style probability models with both maximum likelihood and expectation maximization estimation. Log-linear probability models are also available, and can be trained with maximum likelihood estimation. All of these functions are available through command-line tools, a Java API, and a GUI, seen in Fig.  2 and 3 . We have invested considerable effort into making these algorithms efficient enough for practical use. In particular, many algorithms for wRTGs in Alto are implemented in a lazy fashion, i.e. the rules of the wRTG are only calculated by need; see e.g.  (Groschwitz et al., 2015; Groschwitz et al., 2016) . Obviously, Alto cannot be as efficient for well-established tasks like PCFG parsing  as a parser that was implemented and optimized for this specific grammar formalism. Nonetheless, Alto is fast enough for practical use with treebank-scale gramars, and for less mainstream grammar formalisms can be faster than specialized implementations for these formalisms. For instance, Alto is the fastest published parser for Hyperedge Replacement Grammars  (Groschwitz et al., 2015) . Alto contains multiple algorithms for computing the intersection and inverse homomorphism of RTGs, and a user can choose the combination that works best for their particular grammar formalism  (Groschwitz et al., 2016) . The most recent version adds further performance improvements through the use of a number of pruning techniques, including coarse-to-fine parsing  (Charniak et al., 2006) . With these, Section 23 of the WSJ corpus can be parsed in a couple of minutes. 

 Extending Alto As explained above, Alto can capture any grammar formalism whose derivation trees can be described with a wRTG, by interpreting these into different algebras. For instance, the difference between Context-Free and Tree-Adjoining Grammars in Alto is that CFGs use the simple string algebra outlined in Section 2, whereas for TAG we use a special "TAG string algebra" which defines string wrapping operations  (Koller and Kuhlmann, 2012) . All algorithms mentioned in Section 3 are generic and do not make any assumptions about what algebras are being used. As explained above, the only algebra-specific step is to compute decomposition grammars for input objects. In order to implement a new algebra, a user of Alto simply derives a class from the abstract base class Algebra, which amounts to specifying the possible values of the algebra (as a Java class) and implementing the operations of the algebra as Java methods. If Alto is also to parse objects from this algebra, the class needs to implement a method for computing decomposition grammars for the algebra's values. Alto comes with a number of algebras built in, including string algebras for Context-Free and Tree-Adjoining grammars as well as tree, set, and graph algebras. All of these can be used in parsing. By parsing sets in a set-to-string grammar for example, Alto can generate referring expressions  (Engonopoulos and Koller, 2014) . Finally, Alto has a flexible system of input and output codecs, which can map grammars and algebra values to string representations and vice versa. A key use of these codecs is reading grammars in native input format and converting them into IRTGs. Users can provide their own codecs to maximize interoperability with existing code. 

 Conclusion and Future Work Alto is a flexible tool for the rapid implementation of new formalisms. This flexibility is based on a division of concerns between the generation and the interpretation of grammatical derivations. We hope that the research community will use Alto on newly developed formalisms and on novel combinations for existing algebras. Further, the toolkit's focus on balancing generality with efficiency supports research using larger datasets and grammars. In the future, we will implement algorithms for the automatic induction of IRTG grammars from corpora, e.g. string-to-graph corpora, such as the AMRBank, for semantic parsing  (Banarescu et al., 2013) . This will simplify the prototyping process for new formalisms even further, by making largescale grammars for them available more quickly. Furthermore, we will explore ways for incorporating neural methods into Alto, e.g. in terms of supertagging  (Lewis et al., 2016) . Figure 2 : 2 Figure 2: An example IRTG with an English and a semantic interpretation (Alto screenshot). 
