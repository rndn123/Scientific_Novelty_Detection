title
Advancements in Reordering Models for Statistical Machine Translation
abstract
In this paper , we propose a novel reordering model based on sequence labeling techniques .
Our model converts the reordering problem into a sequence labeling problem , i.e. a tagging task .
Results on five Chinese- English NIST tasks show that our model improves the baseline system by 1.32 BLEU and 1.53 TER on average .
Results of comparative study with other seven widely used reordering models will also be reported .
Introduction
The systematic word order difference between two languages poses a challenge for current statistical machine translation ( SMT ) systems .
The system has to decide in which order to translate the given source words .
This problem is known as the reordering problem .
As shown in ( Knight , 1999 ) , if arbitrary reordering is allowed , the search problem is NP - hard .
Many ideas have been proposed to address the reordering problem .
Within the phrase - based SMT framework there are mainly three stages where improved reordering could be integrated :
In the preprocessing : the source sentence is reordered by heuristics , so that the word order of source and target sentences is similar .
( Wang et al. , 2007 ) use manually designed rules to reorder parse trees of the source sentences .
Based on shallow syntax , ( Zhang et al. , 2007 ) use rules to reorder the source sentences on the chunk level and provide a source- reordering lattice instead of a single reordered source sentence as input to the SMT system .
Designing rules to reorder the source sentence is conceptually clear and usually easy to implement .
In this way , syntax information can be incorporated into phrase - based SMT systems .
However , one disadvantage is that the reliability of the rules is often language pair dependent .
In the decoder : we can add constraints or models into the decoder to reward good reordering options or penalize bad ones .
For reordering constraints , early work includes ITG constraints ( Wu , 1995 ) and IBM constraints ( Berger et al. , 1996 ) . ( Zens and Ney , 2003 ) did comparative study over different reordering constraints .
This paper focuses on reordering models .
For reordering models , we can further roughly divide the existing methods into three genres : ?
The reordering is a classification problem .
The classifier will make decision on next phrase 's relative position with current phrase .
The classifier can be trained with maximum likelihood like Moses lexicalized reordering and hierarchical lexicalized reordering model ( Galley and Manning , 2008 ) or be trained under maximum entropy framework ( Zens and Ney , 2006 ) . ?
The reordering is a decoding order problem .
( Mari?o et al. , 2006 ) present a translation model that constitutes a language model of a sort of bilanguage composed of bilingual units .
From the reordering point of view , the idea is that the correct reordering is a suitable order of translation units .
( Feng et al. , 2010 ) present a simpler version of ( Mari?o et al. , 2006 ) 's model which utilize only source words to model the decoding order .
?
The reordering can be solved by outside heuristics .
We can put human knowledge into the decoder .
For example , the simple jump model using linear distance tells the decoder that usually the long range reordering should be avoided .
( Cherry , 2008 ) uses information from dependency trees to make the decoding process keep syntactic cohesion .
( Feng et al. , 2012 ) present a method that utilizes predicate - argument structures from semantic role labeling results as soft constraints .
In the reranking framework : in principle , all the models in previous category can be used in the reranking framework , because in the reranking we have all the information ( source and target words / phrases , alignment ) about the translation process .
( Och et al. , 2004 ) describe the use of syntactic features in the rescoring step .
However , they report the syntactic features contribute very small gains .
One disadvantage of carrying out reordering in reranking is the representativeness of the N-best list is often a question mark .
In this paper , we propose a novel tagging style reordering model which is under the category " The reordering is a decoding order problem " .
Our model converts the decoding order problem into a sequence labeling problem , i.e. a tagging task .
The remainder of this paper is organized as follows :
Section 2 introduces the basement of this research : the principle of statistical machine translation .
Section 3 describes the proposed model .
Section 4 briefly describes several reordering models with which we compare our method .
Section 5 provides the experimental configuration and results .
Conclusion will be given in Section 6 .
Translation System Overview
In statistical machine translation , we are given a source language sentence f J 1 = f 1 . . . f j . . . f J .
The objective is to translate the source into a target language sentence e I 1 = e 1 . . . e i . . . e I .
The strategy is to choose the target sentence with the highest probability among all others : ? i = arg max I , e I 1 { P r( e I 1 |f J 1 ) } ( 1 ) We model P r(e I 1 |f J 1 ) directly using a log-linear combination of several models : P r(e I 1 |f J 1 ) = exp M m=1 ? m h m ( e I 1 , f J 1 ) I ,e I 1 exp M m=1 ? m h m ( e I 1 , f J 1 ) ( 2 )
The denominator is to make the P r(e I 1 |f J 1 ) to be a probability distribution and it depends only on the source sentence f J 1 .
For search , the decision rule is simply : ? i = arg max I, e I 1 M m=1 ? m h m ( e I 1 , f J 1 ) ( 3 )
The model scaling factors ?
M 1 are trained with Minimum Error Rate Training ( MERT ) .
In this paper , the phrase - based machine translation system is utilized ( Och et al. , 1999 ; Zens et al. , 2002 ; Koehn et al. , 2003 ) .
Tagging -style Reordering Model
In this section , we describe the proposed novel model .
First we will describe the training process .
Then we explain how to use the model in the decoder .
Modeling Figure 1 shows the modeling steps .
The first step is word alignment training .
Figure 1 ( a ) is an example after GIZA ++ training .
If we regard this alignment as a translation result , i.e. given the source sentence f 7 1 , the system translates it into the target sentence e 7 1 , then the alignment link set { a 1 = 3 , a 3 = 2 , a 4 = 4 , a 4 = 5 , a 5 = 7 , a 6 = 6 , a 7 = 6 } reveals the decoding process , i.e. the alignment implies the order in which the source words should be translated , e.g. the first generated target word e 1 has no alignment , we can regard it as a translation from a NULL source word ; then the second generated target word e 2 is translated from f 3 .
We reorder the source side of the alignment to get Figure 1 ( b ) . Figure 1 ( b ) implies the source sentence decoding sequence information , which is depicted in Figure 1 ( c ) .
Using this example we describe the strategies we used for special cases in the transformation from Figure 1 ( b ) to Figure 1 ( c ) : ?
ignore the unaligned target word , e.g. e 1 ? the unaligned source word should follow its preceding word , the unaligned feature is kept with a * symbol , e.g. f * 2 is after f 1 ? when one source word is aligned to multiple target words , only keep the alignment that links the source word to the first target word , e.g. f 4 is linked to e 5 and e 6 , only f 4 ? e 5 is kept .
In other words , we use this strategy to guarantee that every source word appears only once in the source decoding sequence .
? when multiple source words are aligned to one target word , put together the source words according to their original relative positions , e.g. e 6 is linked to f 6 and f 7 .
So in the decoding sequence , f 6 is before f 7 . Now Figure 1 ( c ) shows the original source sentence and its decoding sequence .
By using the strategies above , it is guaranteed that the source sentence and its decoding sequence have the ex - ( e ) Figure 1 : modeling process illustration .
actly same length .
Hence the relation can be modeled by a function F ( f ) which assigns a value for each source word f . Figure 1 ( d ) manifests this function .
The positive function values mean that compared to the original position in the source sentence , its position in the decoding sequence should move rightwards .
If the function value is 0 , the word 's position in original source sentence and its decoding sequence is same .
For example , f 1 is the first word in the source sentence but it is the second word in the decoding sequence .
So its function value is + 1 ( move rightwards one position ) .
Now Figure 1 ( d ) converts the reordering problem into a sequence labeling or tagging problem .
To make the computational cost to a reasonable level , we do a final step simplification in Figure 1 ( e ) .
Suppose the longest sentence length is 100 , then according to Figure 1 ( d ) , there are 200 tags ( from - 99 to + 99 plus the unalign tag ) .
As we will see later , this number is too large for our task .
We instead design nine tags .
For a source word f j in one source sentence f J 1 , the tag of f j will be one of the following :
Unalign f j is an unaligned source word BEGIN - Rmono j = 1 and f j+1 is translated after f j ( Rmono for right monotonic ) BEGIN - Rreorder j = 1 and f j+1 is translated before f j ( Rreorder for right reordered ) END - Lmono j = J and f j?1 translated before f j ( Lmono for left monotonic ) END - Lreorder j = J and f j?1 translated after f j ( Lreorder for left reordered ) Lmono-Rmono 1 < j < J and f j?1 translated before f j and f j translated before f j+1 Lreorder - Rmono 1 < j < J and f j?1 translated after f j and f j translated before f j+1 Lmono-Rreorder 1 < j < J and f j?1 translated before f j and f j translated after f j+1 Lreorder-Rreorder 1 < j < J and f j?1 trans - lated after f j and f j translated after f j+1 Up to this point , we have converted the reordering problem into a tagging problem with nine tags .
The transformation in Figure 1 is conducted for all the sentence pairs in the bilingual training corpus .
After that , we have built an " annotated " corpus for the training .
For this supervised learning task , we choose the approach conditional random fields ( CRFs ) ( Lafferty et al. , 2001 ; Sutton and Mccallum , 2006 ; Lavergne et al. , 2010 ) and recurrent neural network ( RNN ) ( Elman , 1990 ; Jordan , 1990 ; Lang et al. , 1990 ) .
For the first method , we adopt the linear-chain CRFs .
However , even for the simple linear-chain CRFs , the complexity of learning and inference grows quadratically with respect to the number of output labels and the amount of structural features which are with regard to adjacent pairs of labels .
Hence , to make the computational cost as low as possible , two measures have been taken .
Firstly , as described above we reduce the number of tags to nine .
Secondly , we add source sentence part-ofspeech ( POS ) tags to the input .
For features with window size one to three , both source words and its POS tags are used .
For features with window size four and five , only POS tags are used .
As the second method , we use recurrent neural network ( RNN ) .
RNN is closely related with Multilayer Perceptrons ( MLP ) ( Rumelhart et al. , 1986 ) , but the output of one ore more hidden layers is reused as additional inputs for the network in the next time step .
This structure allows the RNN to learn whole sequences without restricting itself to a fixed input window .
A plain RNN has only access to the previous events in the input sequence .
Hence we adopt the bidirectional RNN ( BRNN ) ( Schuster and Paliwal , 1997 ) which reads the input sequence from both directions before making the prediction .
The long short-term memory ( LSTM ) ( Hochreiter and Schmidhuber , 1997 ) is applied to counter the effects that long distance dependencies are hard to learn with gradient descent .
This is often referred to as vanishing gradient problem ( Bengio et al. , 1994 ) .
Decoding
Once the model training is finished , we make inference on develop and test corpora which means that we get the labels of the source sentences that need to be translated .
In the decoder , we add a new model which checks the labeling consistency when scoring an extended state .
During the search , a sentence pair ( f J 1 , e I 1 ) will be formally splitted into a segmentation S K 1 which consists of K phrase pairs .
Each s k = ( i k ; b k , j k ) is a triple consisting of the last position i k of the kth target phrase ?k .
The start and end position of the kth source phrase fk are b k and j k .
Suppose the search state is now extended with a new phrase pair ( fk , ?k ) : fk := f b k . . . f j k and ?k := e i k?1 +1 . . . e i k .
We have access to the old coverage vector , from which we know if the new phrase 's left neighboring source word f b k ?1 and right neighboring source word f j k + 1 have been translated .
We also have the word alignment within the new phrase pair , which is stored during the phrase extraction process .
Based on the old coverage vector and alignment , we can repeat the transformation in Figure 1 to calculate the labels for the new phrase .
The added model will then check the consistence between the calculated labels and the labels predicted by the reordering model .
The number of source words that have inconsistent labels is the penalty and is then added into the log-linear framework as a new feature .
Comparative Study
The second part of this paper is comparative study on reordering models .
Here we briefly describe those models which will be compared to later .
Moses contains a wordbased orientation model , which has three types of reordering : ( m ) monotone order , ( s ) switch with previous phrase and ( d ) discontinuous .
Figure 2 is an example .
The definitions of reordering types are as follows : monotone for current phrase , if a word alignment to the bottom left ( point A ) exists and there is no word alignment point at the bottom right position ( point B ) . swap for current phrase , if a word alignment to the bottom right ( point B ) exists and there is no word alignment point at the bottom left position ( point A ) . discontinuous all other cases
Our implementation is same with the default behavior of Moses lexicalized reordering model .
We count how often each extracted phrase pair is found with each of the three reordering types .
The add - 0.5 smoothing is then applied .
Finally , the probability is estimated with maximum likelihood principle .
Moses lexicalized reordering model
Maximum entropy reordering model Figure 3 is an illustration of ( Zens and Ney , 2006 ) . j is the source word position which is aligned to the last target word of the current phrase .
j is the last source word position of the current phrase .
j is the source word position which is aligned to the first target word position of the next phrase .
( Zens and Ney , 2006 ) proposed a maximum entropy classifier to predict the orientation of the next phrase given the current phrase .
The orientation class c j , j , j is defined as : c j , j , j = ? ? ? left , if j <j right , if j >j and j ? j >1 monotone , if j >j and j ? j = 1 ( 4 )
The orientation probability is modeled in a loglinear framework using a set of N feature functions h n ( f J 1 , e I 1 , i , j , c j , j , j ) , n = 1 , . . . , N .
The whole model is : p ?
N 1 ( c j , j , j |f J 1 , e I 1 , i , j ) = exp ( N n=1 ?nhn(f J 1 , e I 1 , i , j , c j , j , j ) ) c exp ( N n=1 ?nhn(f J 1 , e I 1 , i , j , c ) ) ( 5 ) Different features can be used , we use the source and target word features to train the model .
f 1 f 2 f 3 f 4 f 5 f 6 f 7 e 1 e 2 e 3 e 4 e 5 e 6 e 7 Figure 4 : bilingual LM illustration .
The bilingual sequence is e1 , e2 f3 , e3 f1 , e4 f4 , e5 f4 , e6 f6 f7 , e7 f5 .
Bilingual LM
The previous two models belong to " The reordering is a classification problem " .
Now we turn to " The reordering is a decoding order problem " .
( Mari?o et al. , 2006 ) implement a translation model using n-grams .
In this way , the translation system can take full advantage of the smoothing and consistency provided by standard back - off ngram models .
Figure 4 is an example .
The interpretation is that given the sentence pair ( f 7 1 , e 7 1 ) and its alignment , the correct translation order is e 1 , e 2 f 3 , e 3 f 1 , e 4 f 4 , e 5 f 4 , e 6 f 6 f 7 , e 7 f 5 .
Notice the bilingual units have been ordered according to the target side , as the decoder writes the translation in a left-to- right way .
Using the example we describe the strategies used for special cases : ? keep the unaligned target word , e.g. e 1 ? remove the unaligned source word , e.g. f 2 ? when one source word aligned to multiple target words , duplicate the source word for each target word , e.g. e 4 f 4 , e 5 f 4 ? when multiple source words aligned to one target word , put together the source words for that target word , e.g. e 6 f 6 f 7 After the operation in Figure 4 was done for all bilingual sentence pairs , we get a decoding sequence corpus .
We build a 9 - gram LM using SRILM toolkit ( Stolcke , 2002 ) with modified Kneser - Ney smoothing .
The model is added as an additional feature in Equation ( 2 ) .
To use the bilingual LM , the search state must be augmented to keep the bilingual unit decoding sequence .
In search , the bilingual LM is applied similar to the standard target side LM .
The bilingual sequence of phrase pairs will be extracted using the same strategy in Figure 4 .
Suppose the search state is now extended with a new phrase pair ( f , ? ) .
F is the bilingual sequence for the new phrase pair ( f , ? ) and F i is the i th unit within F . F is the bilingual sequence history for current state .
We compute the feature score h bilm ( F , F ) of the extended state as follows : h bilm ( F , F ) =?
? | F | i=1 log p( F i | F , F 1 , ? ? ? , F i?1 ) ( 6 ) ? is the scaling factor for this model .
| F | is the length of the bilingual decoding sequence .
4.4 Source decoding sequence LM ( Feng et al. , 2010 ) present an simpler version of the above bilingual LM where they use only the source side to model the decoding order .
The source word decoding sequence in Figure 4 is then f 3 , f 1 , f 2 , f 4 , f 6 , f 7 , f 5 .
We also build a 9 - gram LM based on the source word decoding sequences .
The usage of the model is same as bilingual LM .
Syntactic cohesion model
The previous two models belong to " The reordering is a decoding order problem " .
Now we turn to " The reordering can be solved by outside heuristics " .
( Cherry , 2008 ) proposed a syntactic cohesion model .
The core idea is that the syntactic structure of the source sentence should be preserved during translation .
This structure is represented by a source sentence dependency tree .
The algorithm is as follows : given the source sentence and its dependency tree , during the translation process , once a hypothesis is extended , check if the source dependency tree contains a subtree T such that : ?
Its translation is already started ( at least one node is covered ) ?
It is interrupted by the new added phrase ( at least one word in the new source phrase is not in T ) ?
It is not finished ( after the new phrase is added , there is still at least one free node in T ) If so , we say this hypothesis violates the subtree T , and the model returns the number of subtrees that this hypothesis violates .
( Feng et al. , 2012 ) propose two structure features from semantic role labeling ( SRL ) results .
Similar to the previous model , the SRL information is used as soft constraints .
During decoding process , the first feature will report how many event layers that one search state violates and the second feature will report the amount of semantic roles that one search state violates .
In this paper , the two features have been used together .
So when the semantic cohesion model is used , both features will be triggered .
Semantic cohesion model
4.7
Tree- based jump model ( Wang et al. , 2007 ) present a pre-reordering method for Chinese -English translation task .
In Section 3.6 of ( Zhang , 2013 ) , instead of doing hard reordering decision , the author uses the rules as soft constraints in the decoder .
In this paper , we use the similar method as described in ( Zhang , 2013 ) .
Our strategy is : firstly , we parse the source sentences to get constituency trees .
Then we manipulate the trees using heuristics described by ( Wang et al. , 2007 ) .
The leaf nodes in the revised tree constitute the reordered source sentence .
Finally , in the log-linear framework ( Equation 2 ) a new jump model is added which uses the reordered source sentence to calculate the cost .
For example , the original sentence f 1 f 2 f 3 f 4 f 5 is now converted by rules into the new sentence f 1 f 5 f 3 f 2 f 4 .
For decoding , we still use the original sentence .
Suppose previously translated source phrase is f 1 and the current phrase is f 5 .
Then the standard jump model gives cost q Dist = 4 and the new tree - based jump model will return a cost q Dist new = 1 .
Experiments
In this section , we describe the baseline setup , the CRFs training results , the RNN training results and translation experimental results .
Experimental Setup
Our baseline is a phrase - based decoder , which includes the following models : an n-gram targetside language model ( LM ) , a phrase translation model and a word- based lexicon model .
The latter two models are used for both directions : p( f |e ) and p( e | f ) .
Additionally we use phrase count features , word and phrase penalty .
The reordering model for the baseline system is the distancebased jump model which uses linear distance .
This model does not have hard limit .
We list the important information regarding the experimental setup below .
All those conditions have been kept same in this work .
? lowercased training data from the GALE task ( trained by SRILM toolkit ( Stolcke , 2002 ) with modified Kneser - Ney smoothing training data : target side of bilingual data .
? BLEU ( Papineni et al. , 2001 ) and TER ( Snover et al. , 2005 ) reported all scores calculated in lowercase way .
?
Wapiti toolkit ( Lavergne et al. , 2010 ) 1 contains the data statistics used for translation model and LM .
For the reordering model , we take two further filtering steps .
Firstly , we delete the sentence pairs if the source sentence length is one .
When the source sentence has only one word , the translation will be always monotonic and the reordering model does not need to learn this .
Secondly , we delete the sentence pairs if the source sentence contains more than three contiguous unaligned words .
When this happens , the sentence pair is usually low quality hence not suitable for learning .
The main purpose of the two filtering steps is to further lay down the computational burden .
The label distribution is depicted in Figure 5 .
We can see that most words are monotonic .
We then divide the corpus to three parts :
CRFs Training Results
The toolkit Wapiti ( Lavergne et al. , 2010 ) is used in this paper .
We choose the classical optimization algorithm limited memory BFGS ( L- BFGS ) ( Liu and Nocedal , 1989 ) .
For regularization , Wapiti uses both the 1 and 2 penalty terms , yielding the elastic-net penalty of the form ?
1 ? ? 1 + ? 2 2 ? ? 2 2 ( 7 ) In this work , we use as many features as possible because 1 penalty ?
1 ? 1 is able to yield sparse parameter vectors , i.e. using a 1 penalty term implicitly performs the feature selection .
The computational costs are given here : on a cluster with two AMD Opteron ( tm ) Processor 6176 ( total 24 cores ) , the training time is about 16 hours , peak memory is around 120G .
Several experiments have been done to find the suitable hyperparameter ?
1 and ?
2 , we choose the model with lowest error rate on validation corpus for translation experiments .
The error rate of the chosen model on test corpus ( the test corpus in Table 2 ) is 25.75 % for token error rate and 69.39 % for sequence error rate .
Table 3 is the feature template we set initially which generates 722 999 637 features .
Some examples are given in Table 4 . After training 36 902 363 features are kept .
RNN Training Results
We also applied RNN to the task as an alternative approach to CRFs .
The here used RNN implementation is RNNLIB which has support for long short term memory ( LSTM ) ( Graves , 2008 ) .
We used a one of k encoding for the input word and also for the labels .
After testing several configurations over the validation corpus we used a network with will show later , the model trained with both CRFs and RNN help to improve the translation quality .
Table 5 and Table 6 demonstrate the confusion matrix of the CRFs and RNN errors over the test corpus .
The rows represent the correct tag that the classifier should have predicted and the columns are the actually predicted tags .
E.g. the number 687724 in first row and first column of Table 5 tells that there are 687724 correctly labeled Unalign tags .
The number 15084 in first row and second column of Table 5 represents that there are 15084 Unalign tags labeled incorrectly to Begin-Rmono .
Therefore , numbers on the diagonal from the upper left to the lower right corner represent the amount of correctly classified tags and all other numbers show the amount of false labels .
The many zeros show that both classifier rarely make mistake for the label " BEGIN - * " which only occur at the beginning of a sentence .
The same is true for the " END - * " labels .
Feature Templates 1 - gram source word features x [ -4,0 ] , x [ -3,0 ] , x [ -2,0 ] , x [ -1,0 ] x[ 0,0 ] , x [ 1,0 ] , x [ 2,0 ] , x [ 3,0 ] , x [ 4,0 ] 1 - gram source POS features x [ -4,1 ] , x [ -3,1 ] , x [ -2,1 ] , x [ -1,1 ] x [ 0,1 ] , x [ 1,1 ] , x [ 2,1 ] , x [ 3,1 ] , x [ 4,1 ] 2 - gram source word features x [-1,0] / x[ 0,0 ] , x [ 0,0 ] / x[ 1,0 ] x [ -1,1] /x[ 0,1 ] , x[ 0,1 ] / x [ 1, 1 ] 3 - gram source word features x [-1,0] /x[ 0,0 ] / x[ 1,0 ] x [-2,0] /x [-1,0] /x[0,0 ] x[ 0,0 ] / x[ 1,0 ] / x[ 2,0 ] 3 - gram source POS features x [ 0,1 ] / x[ 1,1 ] / x[ 2,1 ] x [-2,1] /x[-1,1] /x[0,1 ] x [-1,1] /x[0,1 ] / x[ 1,1 ] 4 - gram source POS features x [ 0,1 ] / x[ 1,1] / x[ 2,1] / x[ 3,1 ] x[ 0,1 ] / x [-1,1] /x[-2,1]/x[-3,1 ] x [-1,1] /x[0,1] /x[ 1,1] / x[ 2,1 ] x [-2,1] /x[-1,1] /x[0,1 ] / x[ 1,1 ] 5 - gram source POS features x [ 0,1 ] / x[ 1,1] / x[ 2,1] / x[ 3,1] / x[ 4,1 ] x [-4,1] /x[-3,1] /x[-2,1] /x[-1,1] /x[0,1 ] x [-2,1] /x[-1,1] /x[0,1] / x[ 1,1 ] / x[ 2,1 ] bigram output label feature x [-1,2] /x[ 0,2 ]
Translation Results Results are summarized in Table 7 . Please read the caption for the meaning of abbreviations .
An Index column is added for score reference convenience ( B for BLEU ; T for TER ) .
For the proposed model , significance testing results on both BLEU and TER are reported ( B2 and B3 compared to B1 , T2 and T3 compared to T1 ) .
We perform bootstrap resampling with bounds estimation as described in ( Koehn , 2004 ) .
The 95 % confidence threshold ( denoted by ? in the table ) is used to draw significance conclusions .
We add a column avg . to show the average improvements .
From Table 7 we see that the proposed reordering model using CRFs improves the baseline by 0.98 BLEU and 1.21 TER on average , while the proposed reordering model using RNN improves the baseline by 1.32 BLEU and 1.53 TER on average .
For line B2 B3 and T2 T3 , most scores are better than their corresponding baseline values with more than 95 % confidence .
The results show that our proposed idea improves the baseline system and RNN trained model performs better than CRFs trained model , in terms of both automatic measure and significance test .
To investigate why RNN has lower performance for the tagging task but achieves better BLEU , we build a 3 - gram LM on the source side of the training corpus in Table 2 and perplexity values are listed in Table 8 .
The perplexity of the test corpus for reordering model comparison is much lower than those NIST corpora for translation experiments .
In other words , there exists mismatch of the data for reordering model training and actual MT data .
This could explain why CRFs is superior to RNN for labeling problem while RNN is better for MT tasks .
For the comparative study , the best method is the tree-based jump model ( JUMPTREE ) .
Our proposed model ranks the second position .
The difference is tiny : on average only 0.08 BLEU ( B3 and B10 ) and 0.15 TER ( T3 and T10 ) .
Even with ; MERO for maximum entropy reordering model ( Zens and Ney , 2006 ) ; BILM for bilingual language model ( Mari?o et al. , 2006 ) and SRCLM for its simpler version source decoding sequence model ( Feng et al. , 2010 ) ; SC for syntactic cohesion model ( Cherry , 2008 ) ; SRL for semantic cohesion model ( Feng et al. , 2012 ) ; JUMPTREE for our tree - based jump model based on ( Wang et al. , 2007 ) .
Conclusion
In this paper , a novel tagging style reordering model has been proposed .
By our method , the reordering problem is converted into a sequence labeling problem so that the whole source sentence is taken into consideration for reordering decision .
By adding an unaligned word tag , the unaligned word phenomenon is automatically implanted in the proposed model .
The model is utilized as soft constraints in the decoder .
In practice , we do not experience decoding memory increase nor speed slow down .
We choose CRFs and RNN to accomplish the sequence labeling task .
The CRFs achieves lower error rate on the tagging task but RNN trained model is better for the translation task .
Experimental results show that our model is stable and improves the baseline system by 0.98 BLEU and 1.21 TER ( trained by CRFs ) and 1.32 BLEU and 1.53 TER ( trained by RNN ) .
Most of the scores are better than their corresponding baseline values with more than 95 % confidence .
We also compare our method with several other popular reordering models .
Our model ranks the second position which is slightly worse than the tree-based jump model .
However , the tree-based jump model relies on manually designed reordering rules which does not exist for many language pairs while our model can be easily adapted to other translation tasks .
We also show that the proposed model is able to improve a very strong baseline system .
The main contributions of the paper are : propose the tagging -style reordering model and improve the translation quality ; compare two sequence labeling techniques CRFs and RNN ; compare our method with seven other reordering models .
To our best knowledge , it is the first time that the above two comparisons have been reported .
Figure 2 : 2 Figure 2 : lexicalized reordering model illustration .
