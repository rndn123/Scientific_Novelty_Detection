title
Arc-swift : A Novel Transition System for Dependency Parsing
abstract
Transition - based dependency parsers often need sequences of local shift and reduce operations to produce certain attachments .
Correct individual decisions hence require global information about the sentence context and mistakes cause error propagation .
This paper proposes a novel transition system , arc-swift , that enables direct attachments between tokens farther apart with a single transition .
This allows the parser to leverage lexical information more directly in transition decisions .
Hence , arc-swift can achieve significantly better performance with a very small beam size .
Our parsers reduce error by 3.7- 7.6 % relative to those using existing transition systems on the Penn Treebank dependency parsing task and English Universal Dependencies .
Introduction
Dependency parsing is a longstanding natural language processing task , with its outputs crucial to various downstream tasks including relation extraction ( Schmitz et al. , 2012 ; Angeli et al. , 2015 ) , language modeling ( Gubbins and Vlachos , 2013 ) , and natural logic inference ( Bowman et al. , 2016 ) .
Attractive for their linear time complexity and amenability to conventional classification methods , transition - based dependency parsers have sparked much research interest recently .
A transition - based parser makes sequential predictions of transitions between states under the restrictions of a transition system ( Nivre , 2003 ) .
Transition - based parsers have been shown to excel at parsing shorter - range dependency structures , as well as languages where non-projective parses are less pervasive ( McDonald and Nivre , 2007 ) .
However , the transition systems employed in state - of - the - art dependency parsers usually define very local transitions .
At each step , only one or two words are affected , with very local attachments made .
As a result , distant attachments require long and not immediately obvious transition sequences ( e.g. , ate?chopsticks in Figure 1 , which requires two transitions ) .
This is further aggravated by the usually local lexical information leveraged to make transition predictions ( Chen and Manning , 2014 ; Andor et al. , 2016 ) .
In this paper , we introduce a novel transition system , arc-swift , which defines non-local transitions that directly induce attachments of distance up to n ( n = the number of tokens in the sentence ) .
Such an approach is connected to graph - based dependency parsing , in that it leverages pairwise scores between tokens in making parsing decisions ( McDonald et al. , 2005 ) .
We make two main contributions in this paper .
Firstly , we introduce a novel transition system for dependency parsing , which alleviates the difficulty of distant attachments in previous systems by allowing direct attachments anywhere in the stack .
Secondly , we compare parsers by the number of mistakes they make in common linguistic con- arc-standard arc-hybrid Shift ( ? , i| ? , A ) ? ( ? | i , ? , A ) LArc ( ?| i| j , ? , A ) ? (?|j , ? , A ? {( j ? i ) }) RArc ( ?| i| j , ? , A ) ? ( ? | i , ? , A ? {( i ? j ) })
Shift ( ? , i| ? , A ) ? ( ? | i , ? , A ) LArc ( ? | i , j|? , A ) ? ( ? , j|? , A ? {( j ? i ) }) RArc ( ?| i| j , ? , A ) ? ( ? | i , ? , A ? {( i ? j ) } ) arc-eager arc-swift Shift ( ? , i| ? , A ) ? ( ? | i , ? , A ) LArc ( ? | i , j|? , A ) ? ( ? , j|? , A ? {( j ? i ) }) RArc ( ? | i , j|? , A ) ? (?| i| j , ? , A ? {( i ? j ) } )
Reduce ( ? | i , ? , A ) ? ( ? , ? , A ) Shift ( ? , i| ? , A ) ? ( ?| i , ? , A ) LArc [ k ] ( ? | i k | . . . | i 1 , j|? , A ) ? ( ? , j|? , A ? {( j ? i k ) }) RArc [ k ] ( ? | i k | . . . | i 1 , j|? , A ) ? ( ?| i k |j , ? , A ? {( i k ? j ) })
Figure 2 : Transitions defined by different transition systems .
structions .
We show that arc-swift parsers reduce errors in attaching prepositional phrases and conjunctions compared to parsers using existing transition systems .
Transition - based Dependency Parsing Transition - based dependency parsing is performed by predicting transitions between states ( see Figure 1 for an example ) .
Parser states are usually written as ( ? | i , j|? , A ) , where ?| i denotes the stack with token i on the top , j| ?
denotes the buffer with token j at its leftmost , and A the set of dependency arcs .
Given a state , the goal of a dependency parser is to predict a transition to a new state that would lead to the correct parse .
A transition system defines a set of transitions that are sound and complete for parsers , that is , every transition sequence would derive a well - formed parse tree , and every possible parse tree can also be derived from some transition sequence .
1 Arc-standard ( Nivre , 2004 ) is one of the first transition systems proposed for dependency parsing .
It defines three transitions : shift , left arc ( LArc ) , and right arc ( RArc ) ( see Figure 2 for definitions , same for the following transition systems ) , where all arc-inducing transitions operate on the stack .
This system builds the parse bottom - up , i.e. , a constituent is only attached to its head after it has received all of its dependents .
A potential drawback is that during parsing , it is difficult to predict if a constituent has consumed all of its right dependents .
Arc-eager ( Nivre , 2003 ) remedies this drawback by defining arc-inducing transitions that operate between the stack and the buffer .
As a result , a constituent no longer needs to be complete 1 We only focus on projective parses for the scope of this paper .
before it can be attached to its head to the left , as a right arc does n't prevent the attached dependent from taking further dependents of its own .
2 Kuhlmann et al. ( 2011 ) propose a hybrid system derived from a tabular parsing scheme , which they have shown both arc-standard and arc-eager can be derived from .
Arc-hybrid combines LArc from arc-eager and RArc from arc-standard to build dependencies bottom - up .
Non-local Transitions with arc-swift
The traditional transition systems discussed in Section 2 only allow very local transitions affecting one or two words , which makes long-distance dependencies difficult to predict .
To illustrate the limitation of local transitions , consider parsing the following sentences : I ate fish with ketchup .
I ate fish with chopsticks .
The two sentences have almost identical structures , with the notable difference that the prepositional phrase is complementing the direct object in the first case , and the main verb in the second .
For arc-standard and arc-hybrid , the parser would have to decide between Shift and RArc when the parser state is as shown in Figure 3a , where stands for either " ketchup " or " chopsticks " .
3 Similarly , an arc-eager parser would deal with the state shown in Figure 3 b .
Making the correct transition requires information about context words " ate " and " fish " , as well as " " .
In these states , parsers would need to incorporate context about " ate " , " fish " , and " " to make the correct local transition .
Parsers employing traditional transition systems would usually incorporate more features about the context in the transition decision , or employ beam search during parsing ( Chen and Manning , 2014 ; Andor et al. , 2016 ) .
In contrast , inspired by graph- based parsers , we propose arc-swift , which defines non-local transitions as shown in Figure 2 .
This allows direct comparison of different attachment points , and provides a direct solution to parsing the two example sentences .
When the arc-swift parser encounters a state identical to Figure 3 b , it could directly compare transitions RArc [ 1 ] and RArc [ 2 ] instead of evaluating between local transitions .
This results in a direct attachment much like that in a graph - based parser , informed by lexical information about affinity of the pairs of words .
Arc-swift also bears much resemblance to arceager .
In fact , an LArc [ k ] transition can be viewed as k ?
1 Reduce operations followed by one LArc in arc-eager , and similarly for RArc [ k ] .
Reduce is no longer needed in arc-swift as it becomes part of LArc [ k ] and RArc [ k ] , removing the ambiguity in derived transitions in arc-eager .
arc-swift is also equivalent to arc-eager in terms of soundness and completeness .
4 A caveat is that the worst- case time complexity of arc-swift is O( n 2 ) instead of O( n ) , which existing transition - based parsers enjoy .
However , in practice the runtime is nearly 4
This is easy to show because in arc-eager , all Reduce transitions can be viewed as preparing for a later LArc or RArc transition .
We also note that similar to arc-eager transitions , arc-swift transitions must also satisfy certain pre-conditions .
Specifically , an RArc [ k ] transition requires that the top k ?
1 elements in the stack are already attached ; LArc [ k ] additionally requires that the k-th element is unattached , resulting in no more than one feasible LArc candidate for any parser state .
linear , thanks to the usually small number of reducible tokens in the stack .
Our model is very similar to that of ( Kiperwasser and , where features are extracted from tokens with bidirectional LSTMs , and concatenated for classification .
For the three traditional transition systems , features of the top 3 tokens on the stack and the leftmost token in the buffer are concatenated as classifier input .
For arc-swift , features of the head and dependent tokens for each arc-inducing transition are concatenated to compute scores for classification , and features of the leftmost buffer token is used for Shift .
For other details we defer to Appendix A .
The full specification of the model can also be found in our released code online at https://github.
com/qipeng /arc-swift .
Experiments
Results
We use static oracles for all transition systems , and for arc-eager we implement oracles that always Shift / Reduce when ambiguity is present ( arceager - S / R ) .
We evaluate our parsers with greedy parsing ( i.e. , beam size 1 ) .
The results are shown in Table 1 . 5 Note that K&G 2016 is trained with a dynamic oracle ( Goldberg and Nivre , 2012 ) , Andor 2016 with a CRF - like loss , and both Andor 2016 and Weiss 2015 employed beam search ( with sizes 32 and 8 , respectively ) .
For each pair of the systems we implemented , we studied the statistical significance of their difference by performing a paired test with 10,000 bootstrap samples on PTB -SD .
Each grid shows adjusted test result for UAS and LAS , respectively , showing whether the system on the row is significantly better than that on the column .
" *** " stands for p < 0.001 , " * * " p < 0.01 , " * " p < 0.05 , and " - " p ? 0.05 .
that with almost the same implementation , arcswift parsers significantly outperform those using traditional transition systems .
We also analyzed the performance of parsers on attachments of different distances .
As shown in Figure 4 , arc-swift is equally accurate as existing systems for short dependencies , but is more robust for longer ones .
While arc-swift introduces direct long-distance transitions , it also shortens the overall sequence necessary to induce the same parse .
A parser could potentially benefit from both factors : direct attachments could make an easier classification task , and shorter sequences limit the effect of error propagation .
However , since the two effects are correlated in a transition system , precise attribution of the gain is out of the scope of this paper .
Computational efficiency .
We study the computational efficiency of the arc-swift parser by 6 https://github.com/tensorflow/models/ blob/master/syntaxnet/g3doc/universal.md comparing it to an arc-eager parser .
On the PTB -SD development set , the average transition sequence length per sentence of arc-swift is 77.5 % of that of arc-eager .
At each step of parsing , arc-swift needs to evaluate only about 1.24 times the number of transition candidates as arc-eager , which results in very similar runtime .
In contrast , beam search with beam size 2 for arc-eager requires evaluating 4 times the number of transition candidates compared to greedy parsing , which results in a UAS 0.14 % worse and LAS 0.22 % worse for arc-eager compared to greedily decoded arcswift .
Linguistic Analysis
We automatically extracted all labelled attachment errors by error type ( incorrect attachment or relation ) , and categorized a few top parser errors by hand into linguistic constructions .
Results on PTB -SD are shown in Table 3 . 7 We note that the arc-swift parser improves accuracy on prepositional phrase ( PP ) and conjunction attachments , while it remains comparable to other parsers on other common errors .
Analysis on EN - UD shows a similar trend .
As shown in the table , there are still many parser errors unaccounted for in our analysis .
We leave this to future work .
Related Work Previous work has also explored augmenting transition systems to facilitate longer - range attachments .
Attardi ( 2006 ) extended the arcstandard system for non-projective parsing , with arc-inducing transitions that are very similar to those in arc-swift .
A notable difference is that their transitions retain tokens between the head and dependent .
Fern?ndez-Gonz?lez and G?mez-Rodr?guez ( 2012 ) augmented the arc-eager system with transitions that operate on the buffer , which shorten the transition sequence by reducing the number of Shift transitions needed .
However , limited by the sparse feature - based classifiers used , both of these parsers just mentioned only allow direct attachments of distance up to 3 and 2 , respectively .
More recently , Sartorio et al. ( 2013 ) extended arc-standard with transitions that directly attach to left and right " spines " of the top two nodes in the stack .
While this work shares very similar motivations as arc-swift , it requires additional data structures to keep track of the left and right spines of nodes .
This transition system also introduces spurious ambiguity where multiple transition sequences could lead to the same correct parse , which necessitates easy - first training to achieve a more noticeable improvement over arcstandard .
In contrast , arc-swift can be easily implemented given the parser state alone , and does not give rise to spurious ambiguity .
For a comprehensive study of transition systems for dependency parsing , we refer the reader to ( Bohnet et al. , 2016 ) , which proposed a generalized framework that could derive all of the traditional transition systems we described by configuring the size of the active token set and the maximum arc length , among other control parameters .
However , this framework does not cover arc-swift in its original form , as the authors limit each of their transitions to reduce at most one token from the active token set ( the buffer ) .
On the other hand , the framework presented in ( G?mez-Rodr? guez and Nivre , 2013 ) does not explicitly make this constraint , and therefore generalizes to arc-swift .
However , we note that arc-swift still falls out of the scope of existing discussions in that work , by introducing multiple Reduces in a single transition .
Conclusion
In this paper , we introduced arc-swift , a novel transition system for dependency parsing .
We also performed linguistic analyses on parser outputs and showed arc-swift parsers reduce errors in conjunction and adverbial attachments compared to parsers using traditional transition systems .
