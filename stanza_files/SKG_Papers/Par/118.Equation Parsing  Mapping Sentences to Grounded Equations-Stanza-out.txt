title
EQUATION PARSING : Mapping Sentences to Grounded Equations
abstract
Identifying mathematical relations expressed in text is essential to understanding a broad range of natural language text from election reports , to financial news , to sport commentaries to mathematical word problems .
This paper focuses on identifying and understanding mathematical relations described within a single sentence .
We introduce the problem of Equation Parsing - given a sentence , identify noun phrases which represent variables , and generate the mathematical equation expressing the relation described in the sentence .
We introduce the notion of projective equation parsing and provide an efficient algorithm to parse text to projective equations .
Our system makes use of a high precision lexicon of mathematical expressions and a pipeline of structured predictors , and generates correct equations in 70 % of the cases .
In 60 % of the time , it also identifies the correct noun phrase ?
variables mapping , significantly outperforming baselines .
We also release a new annotated dataset for task evaluation .
Introduction
Understanding text often involves reasoning with respect to quantities mentioned in it .
Understanding the news article statement in Example 1 requires identifying relevant entities and the mathematical relations expressed among them in text , and determining how to compose them .
Similarly , solving a math word problem with a sentence like Example 2 , requires realizing that it deals with a single number , knowing the meaning of " difference " and compos-Example 1 Emanuel 's campaign contributions total three times those of his opponents put together .
Example 2
Twice a number equals 25 less than triple the same number .
Example 3 Flying with the wind , a bird was able to make 150 kilometers per hour .
Example 4
The sum of two numbers is 80 .
Example 5
There are 54 5 - dollar and 10 dollar notes .
ing the right equation - " 25 " needs to be subtracted from a number only after it is multiplied by 3 .
As a first step towards understanding such relations , we introduce the Equation Parsing task - given a sentence expressing a mathematical relation , the goal is to generate an equation representing the relation , and to map the variables in the equation to their corresponding noun phrases .
To keep the problem tractable , in this paper we restrict the final output equation form to have at most two ( possibly coreferent ) variables , and assume that each quantity mentioned in the sentence can be used at most once in the final equation .
1
In example 1 , the gold output of an equation parse should be V 1 = 3 ? V 2 , with V 1 = " Emanuel 's campaign contributions " and V 2 = " those of his opponents put together " .
The task can be seen as a form of semantic parsing ( Goldwasser and Roth , 2011 ; Kwiatkowski et al. , 2013 ) where instead of mapping a sentence to a logical form , we want to map it to an equation .
However , there are some key differences that make this problem very challenging in ways that differ from the " standard " semantic parsing .
In Equation Parsing , not all the components of the sentence are mapped to the final equation .
There is a need to identify noun phrases that correspond to variables in the relations and determine that some are irrelevant and can be dropped .
Moreover , in difference from semantic parsing into logical forms , in Equation Parsing multiple phrases in the text could correspond to the same variable , and identical phrases in the text could correspond to multiple variables .
We call the problem of mapping noun phrases to variables the problem of grounding variables .
Grounding is challenging for various reasons , key among them are that : ( i ) The text often does not mention " variables " explicitly , e.g. , the sentence in example 3 describes a mathematical relation between the speed of bird and the speed of wind , without mentioning " speed " explicitly .
( ii ) Sometimes , multiple noun phrases could refer to the same variable .
For instance , in example 2 , both " a number " and " the same number " refer to the same variable .
On the other hand , the same noun phrase might refer to multiple variables , as in example 4 , where the noun phrase " two numbers " refer to two variables .
In addition , the task involves deciding which of the quantities identified in the sentence are relevant to the final equation generation .
In example 5 , both " 5 " and " 10 " are not relevant for the final equation " V 1 + V 2 = 54 " .
Finally , the equation needs to be constructed from a list of relevant quantities and grounded variables .
Overall , the output space becomes exponential in the number of quantities mentioned in the sentence .
Determining the final equation that corresponds to the text is an inference step over a very large space .
To address this , we define the concept of " projectivity " - a condition where the final equation can be generated by combining adjacent numbers or variables , and show that most sentences expressing mathematical relations exhibit the projectivity property .
Finally , we restrict our inference procedure to only search over equations which have this property .
Our approach builds on a pipeline of structured predictors that identify irrelevant quantities , recognize coreferent variables , and , finally , generate equations .
We also leverage a high precision lexicon of mathematical expressions and develop a greedy lexicon matching strategy to guide inference .
We discuss and exemplify the advantages of this approach and , in particular , explain where the " standard " NLP pipeline fails to support equation parsing , and necessitates the new approach proposed here .
Another contribution of this work is the development of a new annotated data set for the task of equation parsing .
We evaluate our method on this dataset and show that our method predicts the correct equation in 70 % of the cases and that in 60 % of the time we also ground all variables correctly .
The next section presents a discussion of related work .
Next we formally describe the task of equation parsing .
The following sections describe our equation representation and the concept of projectivity , followed by the description of our algorithm to generate the equations and variable groundings from text .
We conclude with experimental results .
Related Work
The work most related to this paper is ( Madaan et al. , 2016 ) , which focuses on extracting relation triples where one of the arguments is a number .
In contrast , our work deals with multiple variables and complex equations involving them .
There has been a lot of recent work in automatic math word problem solving Roy et al. , 2015 ; Hosseini et al. , 2014 ; Roy and Roth , 2015 ) .
These solvers cannot handle sentences individually .
They require the input to be a complete math word problem , and even then , they only focus on retrieving a set of answer values without mentioning what each answer value corresponds to .
Our work is also conceptually related to work on semantic parsing - mapping natural language text to a formal meaning representation ( Wong and Mooney , 2007 ; Clarke et al. , 2010 ; Cai and Yates , 2013 ; Kwiatkowski et al. , 2013 ; Goldwasser and Roth , 2011 ) .
However , as mentioned earlier , there are some significant differences in the task definition that necessitate the development of a new approach .
The Equation Parsing Task Equation parsing takes as input a sentence x describing a single mathematical equation , comprising one or two variables and other quantities mentioned in x .
Let N be the set of noun phrases in the sentence x .
The output of the task is the mathematical equation described in x , along with a mapping of each variable in the equation to its corresponding noun phrase in N .
We refer to this mapping as the " grounding " of the variable ; the noun phrase represents what the variable stands for in the equation .
Table 1 gives an example of an input and output for the equation parsing of the text in example 2 .
Since an equation can be written in various forms , we use the form which most agrees with text , as our target output .
So , for example 1 , we will choose V 1 = 3 ? V 2 and not V 2 = V 1 ? 3 . In cases where several equation forms seem to be equally likely to be the target equation , we randomly choose one of them , and keep this choice consistent across the dataset .
The Equation Parsing Task Input Twice a number equals 25 less than triple the same number .
Output 2 ? V 1 = ( 3 ? V 1 ) ? 25 ( Equation ) V 1 = " a number " ( Grounding )
Equation Parse Representation
In this section , we introduce an equation parse for a sentence .
An equation parse of a sentence x is a pair ( T , E ) , where T represents a set of triggers extracted from x , and E represents an equation tree formed with the set T as leaves .
We now describe these terms in detail .
Trigger Given a sentence x mentioning a mathematical relation , a trigger can either be a quantity trigger expressed in x , or variable trigger which is a noun phrase in x corresponding to a variable .
A quantity trigger is a tuple ( q , s ) , where q is the numeric value of the quantity mentioned in text , and s is the span of text from the sentence x which refers to the quantity .
A variable trigger is a tuple ( l , s ) , where l represents the label of the variable , and s represents the noun phrase representing the variable .
For example , for the sentence in Fig 1 , the spans " Twice " , " 25 " , and " triple " generate quantity triggers , whereas " a number " and " the same number " generate variable triggers , with label V 1 . Trigger List
The trigger list T for a sentence x contains one trigger for each variable mention and each numeric value used in the final equation expressed 2 , " 2 " ) , ( V 1 , " a number " ) , ( 25 , " 25 " ) , ( 3 , " triple " ) , ( V 1 , " the same number " ) } .
Note that there can be multiple valid trigger lists .
In our example , we could have chosen both variable triggers to point to the same mention " a number " .
Quantity triggers in the trigger list form the quantity trigger list , and the variable triggers in trigger list form the variable trigger list .
Equation Tree
An equation tree of a sentence x is a binary tree whose leaves constitute the trigger list of x , and internal nodes ( except the root ) are labeled with one of the following operations - addition , subtraction , multiplication , division .
In addition , for nodes which are labeled with subtraction or division , we maintain a separate variable to determine order of its children .
The root of the tree is always labeled with the operation equal .
An equation tree is a natural representation for an equation .
Each node n in an equation tree represents an expression EXPR ( n ) , and the label of the parent node determines how the expressions of its children are to be composed to construct its own expression .
Let us denote the label for a non-leaf node
Twice a number equals 25 less than triple the same number .
Sentence
For all non-leaf nodes n , we have Trigger List Equation Tree 2 V 1 25 3 V 1 ? = ? r ? Figure 1 : A sentence EXPR ( n ) = ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? ? EXPR ( lc ( n ) ) ( n ) EXP R ( rc ( n ) ) if ( n ) ? {+ , ? , =} EXPR ( lc ( n ) ) ( n ) EXP R ( rc ( n ) ) if ( n ) ? {? , ?} ? ORDER ( n ) = lr EXPR ( rc ( n ) ) ( n ) EXP R ( lc ( n ) ) if ( n ) ? {? , ?} ? ORDER ( n ) = rl ( 1 ) Given an equation tree T of a sentence , the equation represented by it is the expression generated by the root of T ( following Equation 1 ) .
Referring to the equation tree in Fig 1 , the node marked " ?
r " represents ( 3 ? V 1 ) ? 25 , and the root represents the full equation 2 ? V 1 = ( 3 ? V 1 ) ? 25 .
Projectivity
For each leaf n of an equation tree T , we define a function Location ( ? ) , to indicate the position of the corresponding trigger in text .
We also define for each node n of equation tree T , functions Span-Start ( n ) and Span-End( n ) to denote the minimum span of text containing the leaves of the subtree rooted at n .
We define them as follows : Span-Start ( n ) = ? ? ? ? ? Location ( n ) if n is a leaf min( Span - Start ( lc ( n ) ) , Span-Start ( rc ( n ) ) ) otherwise Span-End( n ) = ? ? ? ? ? Location ( n ) if n is a leaf max ( Span -End ( lc ( n ) ) , Span-End( rc ( n ) ) ) otherwise
An equation tree T is called projective iff for every node n of T , either Span-End ( lc ( n ) ) ? Span-Start ( rc ( n ) ) or Span-End ( rc ( n ) ) ? Span-Start ( lc ( n ) ) .
In other words , the span of the left child and the right child cannot intersect in a projective equation tree 2 .
The key observation , as our corpus analysis indicates , is that for most sentences , there exists a trigger list , such that the equation tree representing the relation in the sentence is projective .
However this might involve mapping two mentions of the same variable to different noun phrases .
Figure 1 shows an example of a projective equation tree , which requires different mentions of V 1 to be mapped to different noun phrases .
If we had mapped both mentions of V 1 to same noun phrase " a number " , the resulting equation tree would not have been projective .
We collected 385 sentences which represent an equation with one or two mentions of variables , and each number in the sentence used at most once in the equation .
We found that only one sentence among these could not generate a projective equation tree .
( See Section 6.1 for details on dataset creation ) .
Therefore , we develop an algorithmic approach for predicting projective equation trees , and show empirically that it compares favourably with ones which do not make the projective assumption .
Predicting Equation Parse Equation parsing of a sentence involves predicting three components - Quantity Trigger List , Variable Trigger List and Equation Tree .
We develop three structured prediction modules to predict each of the above components .
All our prediction modules take a similar form : given input x and output y , we learn a scoring function f w ( x , y ) , which scores how likely is the output y given input x .
The scoring function f w ( x , y ) is linear , f w ( y ) = w T ?( x , y ) , where ?( x , y ) is a feature vector extracted from x and y .
The inference problem , that is , the prediction y * for an input x is then : y * = arg max y?Y f w ( y ) , where Y is the set of all allowed values of y .
Predicting Quantity Trigger List Given input text and the quantities mentioned in it , the role of this step is to identify , for each quantity in the text , whether it should be part of the final equation .
For instance , in example 5 in Section 1 , both " 5 " and " 10 " are not relevant for the final equation " V 1 + V 2 = 54 " .
Similarly , in example 4 , the number " two " is irrelevant for the equation " V 1 + V 2 = 80 " .
We define for each quantity q in the sentence , a boolean value Relevance ( q ) , which is set to true if q is relevant for the final equation , and to f alse otherwise .
For the structured classification , the input x is the sentence along with a set of recognized quantities mentioned in it , and the output y is the relevance values for all quantities in the sentence .
We empirically found that predicting all relevance values jointly performs better than having a binary classifier predict each one separately .
The feature function ?( x , y ) used for the classification generates neighborhood features ( from neighborhood of q ) and quantity features ( properties of the quantity mention ) .
Details added to the appendix .
Predicting Variable Trigger List
The goal of this step is to predict the variable trigger list for the equation .
Our structured classifier takes as input the sentence x , and the output y is either one or two noun-phrases , representing variables in the final equation .
As we pointed out earlier , multiple groundings might be valid for any given variable , hence there can be multiple valid variable trigger lists .
For every sentence x , we construct a set Y of valid outputs .
Each element in Y corresponds to a valid variable trigger list .
Finally , we aim to output only one of the elements of Y .
We modified the standard structured prediction algorithm to consider " superset supervision " and take into account multiple gold structures for an input x .
We assume access to N training examples of the form : ( x 1 , Y 1 ) , ( x 2 , Y 2 ) , . . . , ( x N , Y N ) , where each Y i is a set of valid outputs for the sentence x i .
Since we want to output only one variable trigger list , we want to score at least one y from Y i higher than all other possible outputs , for each x i .
We use a modified latent structured SVM to learn the weight vector w .
The algorithm treats the best choice among all of Y i as a latent variable .
At each iteration , for all x i , the algorithm chooses the best choice y * i from the set Y i , according to the weight vector w .
Then , w is updated by learning on all ( x i , y * i ) by a standard structured SVM algorithm .
The details of the algorithm are in Algorithm 1 .
The distinction from stan - for all ( x i , Y i ) ?
T do 5 : y * i ? arg max y?Y i w T ?( x i , y ) 6 : T ? T ? {( x i , y * i ) }
7 : end for 8 : Update w by running standard Structural SVM algorithm on T 9 : until convergence 10 : return w dard latent structural SVM is in line 5 of Algorithm 1 .
In order to get the best choice y * i for input x i , we search only inside Y i , instead of all of Y .
A similar formulation can be found in Bj?rkelund and Kuhn ( 2014 ) .
The features ?( x , y ) used for variable trigger prediction include variable features ( properties of noun phrase indicating variable ) and neighborhood features ( lexical features from neighborhood of variable mention ) .
Details added to the appendix .
If the output of the classifier is a pair of noun phrases , we use a rule based variable coreference detector , to determine whether both noun phrases should have the same variable label or not .
The rules for variable coreference are as follows : 1 . If both noun phrases are the same , and they do not have the token " two " or " 2 " , they have the same label .
2 . If the noun phrases are different , and the noun phrase appearing later in the sentence contains tokens " itself " , " the same number " , they have the same label .
3 . In all other cases , they have different labels .
Finally , each noun phrase contributes one variable trigger to the variable trigger list .
Predicting Equation Tree
It is natural to assume that the syntactic parse of the sentence could be very useful in addressing all the predictions we are making in the equation parsing tasks .
However , it turns out that this is not the case - large portions of the syntactic parse will not be part of the equation parse , hence we need the aforementioned modules to address this .
Nevertheless , in the next task of predicting the equation tree , we attempted to constraint the output space using guidance from the syntactic tree ; we found , though , that even enforcing this weak level of output expectation is not productive .
This was due to the poor performance of current syntactic parsers on the equation data ( eg. , in 32 % of sentences , the Stanford parser made a mistake which does not allow recovering the correct equation ) .
The tree prediction module receives the trigger list predicted by the previous two modules , and the goal is to create an equation tree using the trigger list as the leaves of that tree .
The input x is the sentence and the trigger list , and the output y is the equation tree representing the relation described in the sentence .
We assume that the output will be a projective equation tree .
For features ?( x , y ) , we extract for each non-leaf node n of the equation tree y , neighborhood features ( from neighborhood of node spans of n's children ) , connecting text features ( from text between the spans of n's children ) and number features ( properties of number in case of leaf nodes ) .
Details are included in the appendix .
The projectivity assumption implies that the final equation tree can be generated by combining only adjacent nodes , once the set of leaves is sorted based on Span-Start ( ? ) values .
This allows us to use CKY algorithm for inference .
A natural approach to further reduce the output space is to conform to the projective structure of the syntactic parse of the sentence .
However , we found this to adversely affect performance , due to the poor performance of syntactic parser on equation data .
Lexicon
To bootstrap the equation parsing process , we developed a high precision lexicon to translate mathematical expressions to operations and orders , like " sum of A and B " translates to " A+ B " , " A minus B " translates to " A - B " , etc. ( where A and B denote placeholder numbers or expressions ) .
At each step of CKY , while constructing a node n of the equation tree , we check for a lexicon text expression corresponding to node n.
If found , we allow only the corresponding operation ( and order ) for node n , and do not explore other operations or orders .
We show empirically that reducing the space using this greedy lexicon matching help improve performance .
We found that using the lexicon rules as features instead of hard constraints do not help as much .
Note that our lexicon comprises only generic math concepts , and around 50 % of the sentences in our dataset do not contain any pattern from the lexicon .
Finally , given input sentence , we first predict the quantity trigger and the variable trigger lists .
Given the complete trigger list , we predict the equation tree relating the components of the trigger list .
Alternatives
A natural approach could be to jointly learn to predict all three components , to capture the dependencies among them .
To investigate this , we developed a structured SVM which predicts all components jointly , using the union of the features of each component .
We use approximate inference , first enumerating possible trigger lists , and then equation trees , and find the best scoring structure .
However , this method did not outperform the pipeline method .
The worse performance of joint learning is due to : ( 1 ) search space being too large for the joint model to do well given our dataset size of 385 , and ( 2 ) our independent classifiers being good enough , thus supporting better joint inference .
This tradeoff is strongly supported in the literature ( Punyakanok et al. , 2005 ; Sutton and McCallum , 2007 ) .
Another option is to enforce constraints between trigger list predictions , such as , variable triggers should not overlap with the quantity triggers .
However , we noticed that often noun phrases returned by the Stanford parser were noisy , and would include neighboring numbers within the extracted noun phrases .
This prevented us from enforcing such constraints .
Experimental Results
We now describe the data set , and the annotation procedure used .
We then evaluate the system 's performance on predicting trigger list , equation tree , and the complete equation parse .
Dataset
We created a new dataset consisting of 385 sentences extracted from algebra word problems and financial news headlines .
For algebra word problems , we used the MIT dataset , and two high school mathematics textbooks , Elementary Algebra ( College of Redwoods ) and Beginning and Intermediate Algebra ( Tyler Wallace ) .
Financial news headlines were extracted from The Latest News feed of MarketWatch , over the month of February , 2015 .
All sentences with information describing a mathematical relation among at most two ( possibly coreferent ) variables , were chosen .
Next , we pruned sentences which require multiple uses of a number to create the equation .
This only removed a few time related sentences like " In 10 years , John will be twice as old as his son . " .
We empirically found that around 97 % of sentences describing a relation fall under the scope of our dataset .
The annotators were shown each sentence paired with the normalized equation representing the relation in the sentence .
For each variable in the equation , the annotators were asked to mark spans of text which best describe what the variable represents .
The annotation guidelines are provided in the appendix .
We wanted to consider only noun phrase constituents for variable grounding .
Therefore , for each annotated span , we extracted the noun phrase with maximum overlap with the span , and used it to represent the variables .
Finally , a tuple with each variable being mapped to one of the noun phrases representing it , forms a valid output grounding ( variable trigger list ) .
We computed interannotator agreement on the final annotations where only noun phrases represent variables .
The agreement ( kappa ) was 0.668 , indicating good agreement .
The average number of mention annotations per sentence was 1.74 .
Equation Parsing Modules
In this section , we evaluate the performance of the individual modules of the equation parsing process .
We report Accuracy - the fraction of correct predictions .
Table 3 shows the 5 - fold cross validation accuracy of the various modules .
In each case , we also report accuracy by removing each feature group , one at a time .
In addition , for equation tree prediction , we also show the effect of lexicon , projectivity , conforming to syntactic parse constraints , and using lexicon as features instead of hard constraints .
For all our experiments , we use the Stanford Parser ( Socher et al. , 2013 ) , the Illinois POS tagger ( Roth and Zelenko , 1998 ) and the Illinois - SL structured prediction package ( Chang et al. , 2015 ) .
Equation Parsing Results
In this section , we evaluate the performance of our system on the overall equation parsing task .
We report Equation Accuracy - the fraction of sentences for which the system got the equation correct , and Equation + Grounding Accuracy - the fraction of sentences for which the system got both the equation and the grounding of variables correct .
Table 4 shows the overall performance of our system , on a 5 - fold cross validation .
We compare against Joint Learning - a system which jointly learns to predict all relevant components of an equation parse ( Section 5.4 ) .
We also compare with SPF , a publicly available semantic parser , which can learn from sentence -logical form pairs .
We train SPF with sentence -equation pairs and a seed lexicon for mathematical terms ( similar to ours ) , and report equation accuracy .
Our structured predictors pipeline approach is shown to be superior to both Joint Learning and SPF .
SPF gets only a few sentences correct .
We attribute this to the inability of SPF to handle overlapping mentions ( like in Example 4 ) , as well as its approach of parsing the whole sentence to the final output form .
The developers of SPF also confirmed 3 that it is not suitable for equation parsing and that these results are expected .
Since equation parsing is a more involved process , a slight adaptation of SPF does not seem possible , necessitating a more involved process , of the type we propose .
Our approach , in contrast to SPF , can handle overlapping mentions , selects triggers from text , and parses the trigger list to form equations .
3 Private communication
Error Analysis
For variable trigger list prediction , around 25 % of the errors were due to the predictor choosing a span which is contained within the correct span , e.g. , when the target noun phrase is " The cost of a child 's ticket " , our predictor chose only " child 's ticket " .
Although this choice might be sufficient for downstream tasks , we consider it to be incorrect in our current evaluation .
Another 25 % of the errors were due to selection of entities which do not participate in the relation .
For example , in " A rancher raises 5 times as many cows as horses . " , our predictor chose " A rancher " and " cows " as variables , whereas the relation exists between " cows " and " horses " .
For the prediction of the equation tree , we found that 35 % of the errors were due to rare math concepts expressed in text .
For example , " 7 dollars short of the price " represents 7 dollars should be subtracted from the price .
These errors can be handled by carefully augmenting the lexicon .
Another 15 % of the errors were due to lack of world knowledge , requiring understanding of time , speed , and distance .
Conclusion
This paper investigates methods that identify and understand mathematical relations expressed in text .
We introduce the equation parsing task , which involves generating an equation from a sentence and identifying what the variables represent .
We define the notion of projectivity , and construct a high precision lexicon , and use these to reduce the equation search space .
Our experimental results are quite satisfying and raise a few interesting issues .
In particular , it suggests that predicting equation parses using a pipeline of structured predictors performs better than jointly trained alternatives .
As discussed , it also points out the limitation of the current NLP tools in supporting these tasks .
Our current formulation has one key limitation ; we only deal with expressions that are described within a sentence .
Our future work will focus on lifting this restriction , in order to allow relations expressed across multiple sentences and multiple relations expressed in the same sentence .
Code and dataset are available at http://cogcomp.cs.illinois.edu/ page/ publication_view/800 .
by the sentence x .
The trigger list might consist of multiple triggers having the same label , or extracted from the same span of text .
In the example sentence in Fig 1 , the trigger list comprises two triggers having the same label V 1 .
The final trigger list for the example in Fig 1 is { (
